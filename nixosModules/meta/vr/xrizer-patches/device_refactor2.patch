From b8cbcbc41b7cedfd20c48d67752ea9fe2361ee01 Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Tue, 18 Mar 2025 18:45:16 +0100
Subject: [PATCH 01/25] chore: refactor device logic

---
 Cargo.lock                           |  13 ++
 Cargo.toml                           |   1 +
 src/compositor.rs                    |   2 +-
 src/input.rs                         | 230 ++++++++++++---------------
 src/input/action_manifest.rs         |  21 ++-
 src/input/action_manifest/helpers.rs |  12 +-
 src/input/devices.rs                 | 129 +++++++++++++++
 src/input/devices/controller.rs      |  82 ++++++++++
 src/input/devices/hmd.rs             |  53 ++++++
 src/input/devices/tracked_device.rs  | 177 +++++++++++++++++++++
 src/input/legacy.rs                  |  27 ++--
 src/input/skeletal.rs                |  33 ++--
 src/input/tests.rs                   |  11 +-
 src/openxr_data.rs                   |  90 ++++++-----
 src/system.rs                        | 135 +++++++---------
 15 files changed, 729 insertions(+), 287 deletions(-)
 create mode 100644 src/input/devices.rs
 create mode 100644 src/input/devices/controller.rs
 create mode 100644 src/input/devices/hmd.rs
 create mode 100644 src/input/devices/tracked_device.rs

diff --git a/Cargo.lock b/Cargo.lock
index e6a0ec8..febcc7b 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -519,6 +519,18 @@ dependencies = [
  "bytemuck",
 ]
 
+[[package]]
+name = "enum_dispatch"
+version = "0.3.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "aa18ce2bc66555b3218614519ac839ddb759a7d6720732f979ef8d13be147ecd"
+dependencies = [
+ "once_cell",
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
 [[package]]
 name = "env_filter"
 version = "0.1.3"
@@ -2699,6 +2711,7 @@ dependencies = [
  "derive_more",
  "egui",
  "egui-miniquad",
+ "enum_dispatch",
  "env_logger",
  "fakexr",
  "gl",
diff --git a/Cargo.toml b/Cargo.toml
index 897cdcf..df00851 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -36,6 +36,7 @@ workspace = true
 
 [dependencies]
 ash = { workspace = true }
+enum_dispatch = "0.3.13"
 env_logger = "0.11.5"
 glam = { workspace = true }
 log = { workspace = true }
diff --git a/src/compositor.rs b/src/compositor.rs
index 7d5dac8..50cf0d6 100644
--- a/src/compositor.rs
+++ b/src/compositor.rs
@@ -799,7 +799,7 @@ impl vr::IVRCompositor028_Interface for Compositor {
         let input = self.input.force(|_| Input::new(self.openxr.clone()));
 
         let pose = match device_index {
-            vr::k_unTrackedDeviceIndex_Hmd => input.get_hmd_pose(None),
+            vr::k_unTrackedDeviceIndex_Hmd => input.get_device_pose(0, None),
             x if x == openxr_data::Hand::Left as u32 => {
                 input.get_controller_pose(openxr_data::Hand::Left, None)
             }
diff --git a/src/input.rs b/src/input.rs
index d123015..70d4c43 100644
--- a/src/input.rs
+++ b/src/input.rs
@@ -4,9 +4,13 @@ mod legacy;
 mod profiles;
 mod skeletal;
 
+pub mod devices;
+
 #[cfg(test)]
 mod tests;
 
+use devices::tracked_device::TrackedDevice;
+use devices::TrackedDeviceList;
 use profiles::MainAxisType;
 pub use profiles::{InteractionProfile, Profiles};
 use skeletal::FingerState;
@@ -20,7 +24,7 @@ use custom_bindings::{BindingData, GrabActions};
 use glam::Quat;
 use legacy::LegacyActionData;
 use log::{debug, info, trace, warn};
-use openvr::{self as vr, space_relation_to_openvr_pose};
+use openvr as vr;
 use openxr as xr;
 use slotmap::{new_key_type, Key, KeyData, SecondaryMap, SlotMap};
 use std::collections::{HashMap, HashSet, VecDeque};
@@ -50,13 +54,14 @@ pub struct Input<C: openxr_data::Compositor> {
     action_map: RwLock<SlotMap<ActionKey, Action>>,
     set_map: RwLock<SlotMap<ActionSetKey, String>>,
     loaded_actions_path: OnceLock<PathBuf>,
-    cached_poses: Mutex<CachedSpaces>,
     legacy_state: legacy::LegacyState,
     skeletal_tracking_level: RwLock<vr::EVRSkeletalTrackingLevel>,
     profile_map: HashMap<xr::Path, &'static profiles::ProfileProperties>,
     estimated_finger_state: [Mutex<FingerState>; 2],
     events: Mutex<VecDeque<InputEvent>>,
     loading_actions: AtomicBool,
+
+    pub devices: RwLock<TrackedDeviceList>,
 }
 
 struct InputEvent {
@@ -95,6 +100,7 @@ impl<T> Drop for WriteOnDrop<T> {
 
 impl<C: openxr_data::Compositor> Input<C> {
     pub fn new(openxr: Arc<OpenXrData<C>>) -> Self {
+        let devices = TrackedDeviceList::new(&openxr.instance);
         let mut map = SlotMap::with_key();
         let left_hand_key = map.insert(c"/user/hand/left".into());
         let right_hand_key = map.insert(c"/user/hand/right".into());
@@ -110,10 +116,14 @@ impl<C: openxr_data::Compositor> Input<C> {
                 )
             })
             .collect();
+
+        let left_hand = devices.get_controller(Hand::Left.into());
+        let right_hand = devices.get_controller(Hand::Right.into());
+
         let pose_data = PoseData::new(
             &openxr.instance,
-            openxr.left_hand.subaction_path,
-            openxr.right_hand.subaction_path,
+            left_hand.subaction_path,
+            right_hand.subaction_path,
         );
         openxr
             .session_data
@@ -129,10 +139,10 @@ impl<C: openxr_data::Compositor> Input<C> {
             input_source_map: RwLock::new(map),
             action_map: Default::default(),
             set_map: Default::default(),
+            devices: RwLock::new(devices),
             loaded_actions_path: OnceLock::new(),
             left_hand_key,
             right_hand_key,
-            cached_poses: Mutex::default(),
             legacy_state: Default::default(),
             skeletal_tracking_level: RwLock::new(vr::EVRSkeletalTrackingLevel::Estimated),
             profile_map,
@@ -149,9 +159,14 @@ impl<C: openxr_data::Compositor> Input<C> {
         if handle == vr::k_ulInvalidInputValueHandle {
             Some(xr::Path::NULL)
         } else {
+            let devices = self.devices.read().ok()?;
+
+            let left_hand = devices.get_controller(Hand::Left.into());
+            let right_hand = devices.get_controller(Hand::Right.into());
+
             match InputSourceKey::from(KeyData::from_ffi(handle)) {
-                x if x == self.left_hand_key => Some(self.openxr.left_hand.subaction_path),
-                x if x == self.right_hand_key => Some(self.openxr.right_hand.subaction_path),
+                x if x == self.left_hand_key => Some(left_hand.subaction_path),
+                x if x == self.right_hand_key => Some(right_hand.subaction_path),
                 _ => None,
             }
         }
@@ -536,7 +551,6 @@ impl<C: openxr_data::Compositor> vr::IVRInput010_Interface for Input<C> {
 
         if let Some(hand_tracker) = hand_tracker.as_ref() {
             self.get_bone_summary_from_hand_tracking(
-                &self.openxr,
                 &session_data,
                 summary_type,
                 data,
@@ -572,7 +586,6 @@ impl<C: openxr_data::Compositor> vr::IVRInput010_Interface for Input<C> {
 
         if let Some(hand_tracker) = hand_tracker.as_ref() {
             self.get_bones_from_hand_tracking(
-                &self.openxr,
                 &session_data,
                 transform_space,
                 hand_tracker,
@@ -750,16 +763,21 @@ impl<C: openxr_data::Compositor> vr::IVRInput010_Interface for Input<C> {
             }};
         }
         let subaction_path = get_subaction_path!(self, restrict_to_device, action_data);
+        let devices = self.devices.read().unwrap();
+
+        let left_hand = devices.get_controller(Hand::Left.into());
+        let right_hand = devices.get_controller(Hand::Right.into());
+
         let (active_origin, hand) = match loaded.try_get_action(action) {
             Ok(ActionData::Pose) => {
                 let (mut hand, interaction_profile) = match subaction_path {
-                    x if x == self.openxr.left_hand.subaction_path => (
+                    x if x == left_hand.subaction_path => (
                         Some(Hand::Left),
-                        Some(self.openxr.left_hand.profile_path.load()),
+                        Some(left_hand.get_base_device().profile_path.load()),
                     ),
-                    x if x == self.openxr.right_hand.subaction_path => (
+                    x if x == right_hand.subaction_path => (
                         Some(Hand::Right),
-                        Some(self.openxr.right_hand.profile_path.load()),
+                        Some(right_hand.get_base_device().profile_path.load()),
                     ),
                     x if x == xr::Path::NULL => (None, None),
                     _ => unreachable!(),
@@ -767,9 +785,12 @@ impl<C: openxr_data::Compositor> vr::IVRInput010_Interface for Input<C> {
 
                 let get_first_bound_hand_profile = || {
                     loaded
-                        .try_get_pose(action, self.openxr.left_hand.profile_path.load())
+                        .try_get_pose(action, left_hand.get_base_device().profile_path.load())
                         .or_else(|_| {
-                            loaded.try_get_pose(action, self.openxr.right_hand.profile_path.load())
+                            loaded.try_get_pose(
+                                action,
+                                right_hand.get_base_device().profile_path.load(),
+                            )
                         })
                         .ok()
                 };
@@ -1051,8 +1072,12 @@ impl<C: openxr_data::Compositor> vr::IVRInput010_Interface for Input<C> {
             data.session.sync_actions(&sync_sets).unwrap();
         }
 
-        let left_profile = self.openxr.left_hand.profile_path.load();
-        let right_profile = self.openxr.right_hand.profile_path.load();
+        let devices = self.devices.read().unwrap();
+        let left_hand = devices.get_controller(Hand::Left.into());
+        let right_hand = devices.get_controller(Hand::Right.into());
+
+        let left_profile = left_hand.get_base_device().profile_path.load();
+        let right_profile = right_hand.get_base_device().profile_path.load();
         for key in &actions.actions_with_custom_bindings {
             let unsync_custom_bindings = |key, profile| {
                 if profile == xr::Path::NULL {
@@ -1233,61 +1258,68 @@ impl<C: openxr_data::Compositor> Input<C> {
         origin: Option<vr::ETrackingUniverseOrigin>,
     ) {
         tracy_span!();
-        poses[0] = self.get_hmd_pose(origin);
+        let devices = self.devices.read().unwrap();
+        let session_data = self.openxr.session_data.get();
 
-        if poses.len() > Hand::Left as usize {
-            poses[Hand::Left as usize] = self.get_controller_pose(Hand::Left, origin);
-        }
-        if poses.len() > Hand::Right as usize {
-            poses[Hand::Right as usize] = self.get_controller_pose(Hand::Right, origin);
-        }
-    }
+        poses.iter_mut().enumerate().for_each(|(i, pose)| {
+            let device = devices.get_device(i as u32);
 
-    pub fn get_hmd_pose(
-        &self,
-        origin: Option<vr::ETrackingUniverseOrigin>,
-    ) -> vr::TrackedDevicePose_t {
-        tracy_span!();
-        let mut spaces = self.cached_poses.lock().unwrap();
-        let data = self.openxr.session_data.get();
-        spaces.get_pose_impl(
-            &self.openxr,
-            &data,
-            self.openxr.display_time.get(),
-            None,
-            origin.unwrap_or(data.current_origin),
-        )
+            if let Some(device) = device {
+                *pose = device
+                    .get_pose(
+                        &self.openxr,
+                        &session_data,
+                        origin.unwrap_or(session_data.current_origin),
+                    )
+                    .unwrap_or_default();
+            }
+        });
     }
 
     pub fn get_controller_pose(
         &self,
         hand: Hand,
         origin: Option<vr::ETrackingUniverseOrigin>,
+    ) -> vr::TrackedDevicePose_t {
+        self.get_device_pose(hand.into(), origin)
+    }
+
+    pub fn get_device_pose(
+        &self,
+        index: vr::TrackedDeviceIndex_t,
+        origin: Option<vr::ETrackingUniverseOrigin>,
     ) -> vr::TrackedDevicePose_t {
         tracy_span!();
-        let mut spaces = self.cached_poses.lock().unwrap();
-        let data = self.openxr.session_data.get();
-        spaces.get_pose_impl(
-            &self.openxr,
-            &data,
-            self.openxr.display_time.get(),
-            Some(hand),
-            origin.unwrap_or(data.current_origin),
-        )
+
+        let session_data = self.openxr.session_data.get();
+
+        if let Some(device) = self.devices.read().unwrap().get_device(index) {
+            device.get_pose(
+                &self.openxr,
+                &session_data,
+                origin.unwrap_or(session_data.current_origin),
+            ).unwrap_or_default()
+        } else {
+            Default::default()
+        }
     }
 
     pub fn frame_start_update(&self) {
         tracy_span!();
-        std::mem::take(&mut *self.cached_poses.lock().unwrap());
         let data = self.openxr.session_data.get();
         let input_data = &data.input_data;
         if let Some(loaded) = input_data.get_loaded_actions() {
+            let devices = self.devices.read().unwrap();
+
+            let left_hand = devices.get_controller(Hand::Left.into());
+            let right_hand = devices.get_controller(Hand::Right.into());
+
             // If the game has loaded actions, we shouldn't need to sync the state because the game
             // should be doing it itself with UpdateActionState. However, some games (Tea for God)
             // don't actually call UpdateActionState if no controllers are reported as connected,
             // and interaction profiles are only updated after xrSyncActions is called. So here, we
             // do an action sync to try and get the runtime to update the interaction profile.
-            if !self.openxr.left_hand.connected() || !self.openxr.right_hand.connected() {
+            if !left_hand.connected() || !right_hand.connected() {
                 debug!("no controllers connected - syncing info set");
                 data.session
                     .sync_actions(&[xr::ActiveActionSet::new(&loaded.info_set)])
@@ -1337,12 +1369,16 @@ impl<C: openxr_data::Compositor> Input<C> {
     }
 
     fn get_profile_data(&self, hand: Hand) -> Option<&profiles::ProfileProperties> {
-        let hand = match hand {
-            Hand::Left => &self.openxr.left_hand,
-            Hand::Right => &self.openxr.right_hand,
-        };
-        let profile = hand.profile_path.load();
-        self.profile_map.get(&profile).map(|v| &**v)
+        let path = self
+            .devices
+            .read()
+            .ok()?
+            .get_device(hand.into())?
+            .get_base_device()
+            .profile_path
+            .load();
+
+        self.profile_map.get(&path).map(|v| &**v)
     }
 
     pub fn get_controller_string_tracked_property(
@@ -1418,14 +1454,18 @@ impl<C: openxr_data::Compositor> Input<C> {
     }
 
     pub fn post_session_restart(&self, data: &SessionData) {
+        let devices = self.devices.read().unwrap();
+        let left_hand = devices.get_controller(Hand::Left.into());
+        let right_hand = devices.get_controller(Hand::Right.into());
+
         // This function is called while a write lock is called on the session, and as such should
         // not use self.openxr.session_data.get().
         data.input_data
             .pose_data
             .set(PoseData::new(
                 &self.openxr.instance,
-                self.openxr.left_hand.subaction_path,
-                self.openxr.right_hand.subaction_path,
+                left_hand.subaction_path,
+                right_hand.subaction_path,
             ))
             .unwrap_or_else(|_| panic!("PoseData already setup"));
         if let Some(path) = self.loaded_actions_path.get() {
@@ -1463,71 +1503,6 @@ impl<C: openxr_data::Compositor> Input<C> {
     }
 }
 
-#[derive(Default)]
-struct CachedSpaces {
-    seated: CachedPoses,
-    standing: CachedPoses,
-}
-
-#[derive(Default)]
-struct CachedPoses {
-    head: Option<vr::TrackedDevicePose_t>,
-    left: Option<vr::TrackedDevicePose_t>,
-    right: Option<vr::TrackedDevicePose_t>,
-}
-
-impl CachedSpaces {
-    fn get_pose_impl(
-        &mut self,
-        xr_data: &OpenXrData<impl openxr_data::Compositor>,
-        session_data: &SessionData,
-        display_time: xr::Time,
-        hand: Option<Hand>,
-        origin: vr::ETrackingUniverseOrigin,
-    ) -> vr::TrackedDevicePose_t {
-        tracy_span!();
-        let space = match origin {
-            vr::ETrackingUniverseOrigin::Seated => &mut self.seated,
-            vr::ETrackingUniverseOrigin::Standing => &mut self.standing,
-            vr::ETrackingUniverseOrigin::RawAndUncalibrated => unreachable!(),
-        };
-
-        let pose = match hand {
-            None => &mut space.head,
-            Some(Hand::Left) => &mut space.left,
-            Some(Hand::Right) => &mut space.right,
-        };
-
-        if let Some(pose) = pose {
-            return *pose;
-        }
-
-        let (loc, velo) = if let Some(hand) = hand {
-            let pose_data = session_data.input_data.pose_data.get().unwrap();
-            let spaces = match hand {
-                Hand::Left => &pose_data.left_space,
-                Hand::Right => &pose_data.right_space,
-            };
-
-            if let Some(raw) = spaces.try_get_or_init_raw(xr_data, session_data, pose_data) {
-                raw.relate(session_data.get_space_for_origin(origin), display_time)
-                    .unwrap()
-            } else {
-                trace!("failed to get raw space, making empty pose");
-                (xr::SpaceLocation::default(), xr::SpaceVelocity::default())
-            }
-        } else {
-            session_data
-                .view_space
-                .relate(session_data.get_space_for_origin(origin), display_time)
-                .unwrap()
-        };
-
-        let ret = space_relation_to_openvr_pose(loc, velo);
-        *pose.insert(ret)
-    }
-}
-
 enum LoadedActions {
     Legacy(LegacyActionData),
     Manifest(ManifestLoadedActions),
@@ -1649,7 +1624,7 @@ impl Deref for SpaceReadGuard<'_> {
 impl HandSpace {
     pub fn try_get_or_init_raw(
         &self,
-        xr_data: &OpenXrData<impl crate::openxr_data::Compositor>,
+        hand_profile: &Option<&dyn InteractionProfile>,
         session_data: &SessionData,
         pose_data: &PoseData,
     ) -> Option<SpaceReadGuard<'_>> {
@@ -1659,14 +1634,7 @@ impl HandSpace {
                 return Some(SpaceReadGuard(raw));
             }
         }
-
         {
-            let hand_profile = match self.hand {
-                Hand::Right => &xr_data.right_hand.profile,
-                Hand::Left => &xr_data.left_hand.profile,
-            };
-
-            let hand_profile = hand_profile.lock().unwrap();
             let Some(profile) = hand_profile.as_ref() else {
                 trace!("no hand profile, no raw space will be created");
                 return None;
diff --git a/src/input/action_manifest.rs b/src/input/action_manifest.rs
index ea62767..5d2dfe2 100644
--- a/src/input/action_manifest.rs
+++ b/src/input/action_manifest.rs
@@ -99,14 +99,18 @@ impl<C: openxr_data::Compositor> Input<C> {
         )?;
         debug!("Loaded {} action sets.", sets.len());
 
+        let devices = self.devices.read().unwrap();
+        let left_hand = devices.get_controller(Hand::Left.into());
+        let right_hand = devices.get_controller(Hand::Right.into());
+
         let actions = load_actions(
             &self.openxr.instance,
             &session_data.session,
             english.as_ref(),
             &mut sets,
             manifest.actions,
-            self.openxr.left_hand.subaction_path,
-            self.openxr.right_hand.subaction_path,
+            left_hand.subaction_path,
+            right_hand.subaction_path,
         )?;
         debug!("Loaded {} actions.", actions.len());
 
@@ -116,8 +120,8 @@ impl<C: openxr_data::Compositor> Input<C> {
             .get_or_init(|| {
                 SkeletalInputActionData::new(
                     &self.openxr.instance,
-                    self.openxr.left_hand.subaction_path,
-                    self.openxr.right_hand.subaction_path,
+                    left_hand.subaction_path,
+                    right_hand.subaction_path,
                 )
             });
 
@@ -864,9 +868,12 @@ impl<C: openxr_data::Compositor> Input<C> {
                     let bindings = LazyCell::new(load_bindings);
                     for profile in profiles {
                         if let Some(bindings) = bindings.as_ref() {
-                            if let Some(mut context) =
-                                context.for_profile(&self.openxr, profile, other)
-                            {
+                            if let Some(mut context) = context.for_profile(
+                                &self.openxr,
+                                &self.devices.read().unwrap(),
+                                profile,
+                                other,
+                            ) {
                                 self.load_bindings_for_profile(bindings, &mut context);
                             }
                         }
diff --git a/src/input/action_manifest/helpers.rs b/src/input/action_manifest/helpers.rs
index 727c5d9..1816c55 100644
--- a/src/input/action_manifest/helpers.rs
+++ b/src/input/action_manifest/helpers.rs
@@ -2,11 +2,12 @@ use crate::input::action_manifest::{ActionPath, ControllerType, LoadedActionData
 use crate::input::custom_bindings::{
     AsActionData, AsIter, BindingData, CustomBindingHelper, Names,
 };
+use crate::input::devices::TrackedDeviceList;
 use crate::input::skeletal::SkeletalInputActionData;
 use crate::input::ActionData::{Bool, Vector1, Vector2};
 use crate::input::{ActionData, BoundPose, ExtraActionData, InteractionProfile};
-use crate::openxr_data;
 use crate::openxr_data::OpenXrData;
+use crate::openxr_data::{self, Hand};
 use log::{trace, warn};
 use openxr as xr;
 use std::collections::HashMap;
@@ -47,6 +48,7 @@ impl BindingsLoadContext<'_> {
     pub fn for_profile<'a, 'b: 'a, C: openxr_data::Compositor>(
         &'b mut self,
         openxr: &'a OpenXrData<C>,
+        devices: &'a TrackedDeviceList,
         profile: &'a dyn InteractionProfile,
         controller_type: &'a ControllerType,
     ) -> Option<BindingsProfileLoadContext<'a>> {
@@ -56,10 +58,10 @@ impl BindingsLoadContext<'_> {
             return None;
         };
 
-        let hands = [
-            openxr.left_hand.subaction_path,
-            openxr.right_hand.subaction_path,
-        ];
+        let left_hand = devices.get_controller(Hand::Left.into());
+        let right_hand = devices.get_controller(Hand::Right.into());
+
+        let hands = [left_hand.subaction_path, right_hand.subaction_path];
 
         let bindings_parsed = self
             .per_profile_bindings
diff --git a/src/input/devices.rs b/src/input/devices.rs
new file mode 100644
index 0000000..8398d01
--- /dev/null
+++ b/src/input/devices.rs
@@ -0,0 +1,129 @@
+use controller::XrController;
+use enum_dispatch::enum_dispatch;
+use hmd::XrHMD;
+use tracked_device::{BaseDevice, TrackedDevice, TrackedDeviceType};
+
+use openvr as vr;
+use openxr as xr;
+
+use crate::{
+    input::InteractionProfile,
+    openxr_data::{OpenXrData, SessionData},
+};
+
+pub mod controller;
+pub mod hmd;
+pub mod tracked_device;
+
+// enum dispatch generates the trait implementation for this enum,
+// so we can access the methods of the variants without having to match anything manually.
+#[enum_dispatch(TrackedDevice)]
+pub enum TrackedDeviceContainer {
+    HMD(XrHMD),
+    Controller(XrController),
+}
+
+pub struct TrackedDeviceList {
+    pub devices: Vec<TrackedDeviceContainer>,
+}
+
+impl Default for TrackedDeviceList {
+    fn default() -> Self {
+        Self {
+            devices: vec![
+                XrHMD::new().into(),
+            ],
+        }
+    }
+}
+
+#[allow(dead_code)]
+impl TrackedDeviceList {
+    pub fn new(xr_instance: &xr::Instance) -> Self {
+        Self {
+            devices: vec![
+                XrHMD::new().into(),
+                XrController::new(xr_instance, TrackedDeviceType::LeftHand).into(),
+                XrController::new(xr_instance, TrackedDeviceType::RightHand).into(),
+            ],
+        }
+    }
+
+    pub fn get_device(
+        &self,
+        device_index: vr::TrackedDeviceIndex_t,
+    ) -> Option<&TrackedDeviceContainer> {
+        self.devices.get(device_index as usize)
+    }
+
+    pub fn get_device_mut(
+        &mut self,
+        device_index: vr::TrackedDeviceIndex_t,
+    ) -> Option<&mut TrackedDeviceContainer> {
+        self.devices.get_mut(device_index as usize)
+    }
+
+    pub unsafe fn get_device_unchecked(
+        &self,
+        device_index: vr::TrackedDeviceIndex_t,
+    ) -> &TrackedDeviceContainer {
+        self.devices.get_unchecked(device_index as usize)
+    }
+
+    pub unsafe fn get_device_mut_unchecked(
+        &mut self,
+        device_index: vr::TrackedDeviceIndex_t,
+    ) -> &mut TrackedDeviceContainer {
+        self.devices.get_unchecked_mut(device_index as usize)
+    }
+
+    /// This function is only intended to be used for the HMD and controllers. For other devices, it'll return the first match.
+    pub fn get_device_by_type(
+        &self,
+        device_type: TrackedDeviceType,
+    ) -> Option<&TrackedDeviceContainer> {
+        self.devices
+            .iter()
+            .find(|device| device.get_type() == device_type)
+    }
+
+    /// This function is only intended to be used for the HMD and controllers. For other devices, it'll return the first match.
+    pub fn get_device_by_type_mut(
+        &mut self,
+        device_type: TrackedDeviceType,
+    ) -> Option<&mut TrackedDeviceContainer> {
+        self.devices
+            .iter_mut()
+            .find(|device| device.get_type() == device_type)
+    }
+
+    pub fn get_hmd(&self) -> &XrHMD {
+        let hmd = unsafe { self.get_device_unchecked(0) };
+
+        match hmd {
+            TrackedDeviceContainer::HMD(hmd) => hmd,
+            _ => panic!("HMD is not the first device in the list"),
+        }
+    }
+
+    pub fn get_controller(&self, hand: TrackedDeviceType) -> &XrController {
+        let controller = match hand {
+            TrackedDeviceType::LeftHand => unsafe { self.get_device_unchecked(1) },
+            TrackedDeviceType::RightHand => unsafe { self.get_device_unchecked(2) },
+            _ => panic!("Invalid hand type"),
+        };
+
+        match controller {
+            TrackedDeviceContainer::Controller(controller) => controller,
+            _ => panic!("Controller is not the second or third device in the list"),
+        }
+    }
+
+    pub fn iter(&self) -> std::slice::Iter<'_, TrackedDeviceContainer> {
+        self.devices.iter()
+    }
+
+    pub fn len(&self) -> usize {
+        self.devices.len()
+    }
+}
diff --git a/src/input/devices/controller.rs b/src/input/devices/controller.rs
new file mode 100644
index 0000000..2e73f3a
--- /dev/null
+++ b/src/input/devices/controller.rs
@@ -0,0 +1,82 @@
+use super::tracked_device::{BaseDevice, TrackedDevice};
+
+use log::trace;
+use openvr::{self as vr, space_relation_to_openvr_pose};
+use openxr as xr;
+
+use crate::{
+    input::devices::tracked_device::TrackedDeviceType,
+    openxr_data::{OpenXrData, SessionData},
+    tracy_span,
+};
+
+pub struct XrController {
+    base: BaseDevice,
+
+    pub hand_path: &'static str,
+    pub subaction_path: xr::Path,
+}
+
+impl XrController {
+    pub fn new(instance: &xr::Instance, device_type: TrackedDeviceType) -> Self {
+        assert!(
+            device_type == TrackedDeviceType::LeftHand
+                || device_type == TrackedDeviceType::RightHand,
+            "Invalid device type \"{}\" for controller",
+            device_type
+        );
+
+        let hand_path = match device_type {
+            TrackedDeviceType::LeftHand => "/user/hand/left",
+            TrackedDeviceType::RightHand => "/user/hand/right",
+            _ => unreachable!(),
+        };
+
+        let subaction_path = instance.string_to_path(hand_path).unwrap();
+
+        Self {
+            base: BaseDevice::new(device_type.into(), device_type),
+            hand_path,
+            subaction_path,
+        }
+    }
+}
+
+impl TrackedDevice for XrController {
+    fn get_pose(
+        &self,
+        xr_data: &OpenXrData<impl crate::openxr_data::Compositor>,
+        session_data: &SessionData,
+        origin: vr::ETrackingUniverseOrigin,
+    ) -> Option<vr::TrackedDevicePose_t> {
+        tracy_span!("XrController::get_pose");
+
+        let pose_data = session_data.input_data.pose_data.get().unwrap();
+        let space = match self.get_type() {
+            TrackedDeviceType::LeftHand => &pose_data.left_space,
+            TrackedDeviceType::RightHand => &pose_data.right_space,
+            _ => return None,
+        };
+
+        let (location, velocity) = if let Some(raw) = space.try_get_or_init_raw(
+            &self.get_interaction_profile(),
+            session_data,
+            &pose_data,
+        ) {
+            raw.relate(
+                session_data.get_space_for_origin(origin),
+                xr_data.display_time.get(),
+            )
+            .ok()?
+        } else {
+            trace!("Failed to get raw space, returning empty pose");
+            (xr::SpaceLocation::default(), xr::SpaceVelocity::default())
+        };
+
+        Some(space_relation_to_openvr_pose(location, velocity))
+    }
+
+    fn get_base_device(&self) -> &BaseDevice {
+        &self.base
+    }
+}
diff --git a/src/input/devices/hmd.rs b/src/input/devices/hmd.rs
new file mode 100644
index 0000000..c72e4d1
--- /dev/null
+++ b/src/input/devices/hmd.rs
@@ -0,0 +1,53 @@
+use std::sync::atomic::Ordering;
+
+use super::tracked_device::{BaseDevice, TrackedDevice, TrackedDeviceType};
+
+use openvr::{self as vr, space_relation_to_openvr_pose};
+
+use crate::{
+    openxr_data::{OpenXrData, SessionData},
+    tracy_span,
+};
+
+pub struct XrHMD {
+    base: BaseDevice,
+}
+
+impl XrHMD {
+    pub fn new() -> Self {
+        let hmd = Self {
+            base: BaseDevice::new(0, TrackedDeviceType::HMD),
+        };
+
+        hmd.base.connected.store(true, Ordering::Relaxed);
+
+        hmd
+    }
+}
+
+impl TrackedDevice for XrHMD {
+    fn get_pose(
+        &self,
+        xr_data: &OpenXrData<impl crate::openxr_data::Compositor>,
+        session_data: &SessionData,
+        origin: vr::ETrackingUniverseOrigin,
+    ) -> Option<vr::TrackedDevicePose_t> {
+        tracy_span!("XrHMD::get_pose");
+
+        let (location, velocity) = {
+            session_data
+                .view_space
+                .relate(
+                    session_data.get_space_for_origin(origin),
+                    xr_data.display_time.get(),
+                )
+                .ok()?
+        };
+
+        Some(space_relation_to_openvr_pose(location, velocity))
+    }
+
+    fn get_base_device(&self) -> &BaseDevice {
+        &self.base
+    }
+}
diff --git a/src/input/devices/tracked_device.rs b/src/input/devices/tracked_device.rs
new file mode 100644
index 0000000..ec2caef
--- /dev/null
+++ b/src/input/devices/tracked_device.rs
@@ -0,0 +1,177 @@
+use std::{
+    fmt,
+    sync::{
+        atomic::{AtomicBool, Ordering},
+        Mutex,
+    },
+};
+
+use enum_dispatch::enum_dispatch;
+use openvr as vr;
+
+use crate::{
+    input::InteractionProfile,
+    openxr_data::{AtomicPath, Hand, OpenXrData, SessionData},
+};
+
+#[derive(Debug, Copy, Clone, PartialEq)]
+#[allow(dead_code)]
+pub enum TrackedDeviceType {
+    HMD,
+    LeftHand,
+    RightHand,
+    GenericTracker,
+    Unknown,
+}
+
+impl fmt::Display for TrackedDeviceType {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        match self {
+            Self::HMD => write!(f, "HMD"),
+            Self::LeftHand => write!(f, "Left Hand"),
+            Self::RightHand => write!(f, "Right Hand"),
+            Self::GenericTracker => write!(f, "Generic Tracker"),
+            Self::Unknown => write!(f, "Unknown"),
+        }
+    }
+}
+
+impl Into<vr::TrackedDeviceIndex_t> for TrackedDeviceType {
+    fn into(self) -> vr::TrackedDeviceIndex_t {
+        match self {
+            Self::HMD => vr::k_unTrackedDeviceIndex_Hmd,
+            Self::LeftHand => vr::k_unTrackedDeviceIndex_Hmd + 1,
+            Self::RightHand => vr::k_unTrackedDeviceIndex_Hmd + 2,
+            Self::GenericTracker => vr::k_unTrackedDeviceIndex_Hmd + 3,
+            Self::Unknown => vr::k_unTrackedDeviceIndexInvalid,
+        }
+    }
+}
+
+impl From<Hand> for TrackedDeviceType {
+    fn from(hand: Hand) -> Self {
+        match hand {
+            Hand::Left => Self::LeftHand,
+            Hand::Right => Self::RightHand,
+        }
+    }
+}
+
+impl Into<vr::ETrackedControllerRole> for TrackedDeviceType {
+    fn into(self) -> vr::ETrackedControllerRole {
+        match self {
+            Self::LeftHand => vr::ETrackedControllerRole::LeftHand,
+            Self::RightHand => vr::ETrackedControllerRole::RightHand,
+            _ => vr::ETrackedControllerRole::Invalid,
+        }
+    }
+}
+
+impl Into<vr::ETrackedDeviceClass> for TrackedDeviceType {
+    fn into(self) -> vr::ETrackedDeviceClass {
+        match self {
+            Self::HMD => vr::ETrackedDeviceClass::HMD,
+            Self::LeftHand | Self::RightHand => vr::ETrackedDeviceClass::Controller,
+            Self::GenericTracker => vr::ETrackedDeviceClass::GenericTracker,
+            Self::Unknown => vr::ETrackedDeviceClass::Invalid,
+        }
+    }
+}
+
+impl From<vr::ETrackedControllerRole> for TrackedDeviceType {
+    fn from(role: vr::ETrackedControllerRole) -> Self {
+        match role {
+            vr::ETrackedControllerRole::LeftHand => Self::LeftHand,
+            vr::ETrackedControllerRole::RightHand => Self::RightHand,
+            _ => Self::Unknown,
+        }
+    }
+}
+
+#[enum_dispatch]
+pub trait TrackedDevice {
+    fn get_pose(
+        &self,
+        xr_data: &OpenXrData<impl crate::openxr_data::Compositor>,
+        session_data: &SessionData,
+        origin: vr::ETrackingUniverseOrigin,
+    ) -> Option<vr::TrackedDevicePose_t>;
+
+    fn get_base_device(&self) -> &BaseDevice;
+
+    fn connected(&self) -> bool {
+        self.get_base_device().connected.load(Ordering::Relaxed)
+    }
+
+    fn set_connected(&self, connected: bool) {
+        self.get_base_device()
+            .connected
+            .store(connected, Ordering::Relaxed);
+    }
+
+    fn get_type(&self) -> TrackedDeviceType {
+        self.get_base_device().device_type
+    }
+
+    fn get_device_index(&self) -> vr::TrackedDeviceIndex_t {
+        self.get_base_device().device_index
+    }
+
+    fn set_interaction_profile(&self, profile: &'static dyn InteractionProfile) {
+        self.get_base_device()
+            .interaction_profile
+            .lock()
+            .unwrap()
+            .replace(profile);
+    }
+
+    fn get_interaction_profile(&self) -> Option<&'static dyn InteractionProfile> {
+        self.get_base_device()
+            .interaction_profile
+            .lock()
+            .unwrap()
+            .as_ref()
+            .copied()
+    }
+}
+
+pub struct BaseDevice {
+    pub device_type: TrackedDeviceType,
+    pub device_index: vr::TrackedDeviceIndex_t,
+    pub interaction_profile: Mutex<Option<&'static dyn InteractionProfile>>,
+    pub profile_path: AtomicPath,
+    pub connected: AtomicBool,
+    pub previous_connected: AtomicBool,
+}
+
+impl Default for BaseDevice {
+    fn default() -> Self {
+        Self {
+            device_type: TrackedDeviceType::Unknown,
+            device_index: vr::k_unTrackedDeviceIndexInvalid,
+            interaction_profile: Mutex::new(None),
+            profile_path: AtomicPath::new(),
+            connected: AtomicBool::new(false),
+            previous_connected: AtomicBool::new(false),
+        }
+    }
+}
+
+impl BaseDevice {
+    pub fn new(device_index: vr::TrackedDeviceIndex_t, device_type: TrackedDeviceType) -> Self {
+        assert!(
+            device_index != vr::k_unTrackedDeviceIndexInvalid,
+            "Cannot create a device with an invalid index"
+        );
+        assert!(
+            device_type != TrackedDeviceType::Unknown,
+            "Cannot create a device with an unknown type"
+        );
+
+        Self {
+            device_type,
+            device_index,
+            ..Default::default()
+        }
+    }
+}
diff --git a/src/input/legacy.rs b/src/input/legacy.rs
index 5cb0afd..31c60cb 100644
--- a/src/input/legacy.rs
+++ b/src/input/legacy.rs
@@ -40,10 +40,15 @@ impl<C: openxr_data::Compositor> Input<C> {
 
         let session_data = self.openxr.session_data.get();
         let session = &session_data.session;
+
+        let devices = self.devices.read().unwrap();
+        let left_hand = devices.get_controller(Hand::Left.into());
+        let right_hand = devices.get_controller(Hand::Right.into());
+
         let legacy = LegacyActionData::new(
             &self.openxr.instance,
-            self.openxr.left_hand.subaction_path,
-            self.openxr.right_hand.subaction_path,
+            left_hand.subaction_path,
+            right_hand.subaction_path,
         );
         let input_data = &session_data.input_data;
 
@@ -102,11 +107,9 @@ impl<C: openxr_data::Compositor> Input<C> {
             debug!("tried triggering haptic on invalid device index: {device_index}");
             return;
         };
-        let hand_info = match hand {
-            Hand::Left => &self.openxr.left_hand,
-            Hand::Right => &self.openxr.right_hand,
-        };
-        let hand_path = hand_info.subaction_path;
+        let devices = self.devices.read().unwrap();
+        let controller = devices.get_controller(hand.into());
+        let hand_path = controller.subaction_path;
 
         let Some(legacy) = data.input_data.get_legacy_actions() else {
             debug!("tried triggering haptic, but legacy actions aren't ready");
@@ -171,11 +174,11 @@ impl<C: openxr_data::Compositor> Input<C> {
             return false;
         };
 
-        let hand_info = match hand {
-            Hand::Left => &self.openxr.left_hand,
-            Hand::Right => &self.openxr.right_hand,
-        };
-        let hand_path = hand_info.subaction_path;
+        let devices = self.devices.read().unwrap();
+
+        let controller = devices.get_controller(hand.into());
+
+        let hand_path = controller.subaction_path;
 
         let data = self.openxr.session_data.get();
 
diff --git a/src/input/skeletal.rs b/src/input/skeletal.rs
index 89f9842..a14f471 100644
--- a/src/input/skeletal.rs
+++ b/src/input/skeletal.rs
@@ -2,7 +2,8 @@
 mod gen;
 
 use super::Input;
-use crate::openxr_data::{self, Hand, OpenXrData, SessionData};
+use crate::input::devices::tracked_device::TrackedDevice;
+use crate::openxr_data::{self, Hand, SessionData};
 use glam::{Affine3A, Quat, Vec3};
 use log::debug;
 use openvr as vr;
@@ -17,7 +18,6 @@ impl<C: openxr_data::Compositor> Input<C> {
     /// Returns false if hand tracking data couldn't be generated for some reason.
     pub(super) fn get_bones_from_hand_tracking(
         &self,
-        xr_data: &OpenXrData<C>,
         session_data: &SessionData,
         space: vr::EVRSkeletalTransformSpace,
         hand_tracker: &xr::HandTracker,
@@ -28,11 +28,19 @@ impl<C: openxr_data::Compositor> Input<C> {
 
         let pose_data = session_data.input_data.pose_data.get().unwrap();
         let display_time = self.openxr.display_time.get();
+        let devices = self.devices.read().unwrap();
+
+        let controller = devices.get_controller(hand.into());
+
         let Some(raw) = match hand {
             Hand::Left => &pose_data.left_space,
             Hand::Right => &pose_data.right_space,
         }
-        .try_get_or_init_raw(xr_data, session_data, pose_data) else {
+        .try_get_or_init_raw(
+            &controller.get_interaction_profile(),
+            session_data,
+            &pose_data,
+        ) else {
             self.get_estimated_bones(session_data, space, hand, transforms);
             return;
         };
@@ -161,7 +169,6 @@ impl<C: openxr_data::Compositor> Input<C> {
 
     pub(super) fn get_bone_summary_from_hand_tracking(
         &self,
-        xr_data: &OpenXrData<C>,
         session_data: &SessionData,
         summary_type: vr::EVRSummaryType,
         summary_data: *mut vr::VRSkeletalSummaryData_t,
@@ -170,11 +177,19 @@ impl<C: openxr_data::Compositor> Input<C> {
     ) {
         let pose_data = session_data.input_data.pose_data.get().unwrap();
         let display_time = self.openxr.display_time.get();
+        let devices = self.devices.read().unwrap();
+
+        let controller = devices.get_controller(hand.into());
+
         let Some(raw) = match hand {
             Hand::Left => &pose_data.left_space,
             Hand::Right => &pose_data.right_space,
         }
-        .try_get_or_init_raw(xr_data, session_data, pose_data) else {
+        .try_get_or_init_raw(
+            &controller.get_interaction_profile(),
+            session_data,
+            pose_data,
+        ) else {
             self.get_estimated_bone_summary(session_data, summary_type, summary_data, hand);
             return;
         };
@@ -334,10 +349,10 @@ impl<C: openxr_data::Compositor> Input<C> {
             .get()
             .unwrap()
             .actions;
-        let subaction = match hand {
-            Hand::Left => self.openxr.left_hand.subaction_path,
-            Hand::Right => self.openxr.right_hand.subaction_path,
-        };
+
+        let devices = self.devices.read().unwrap();
+
+        let subaction = devices.get_controller(hand.into()).subaction_path;
 
         let thumb_touch = actions
             .thumb_touch
diff --git a/src/input/tests.rs b/src/input/tests.rs
index b0244f5..97bd3cc 100644
--- a/src/input/tests.rs
+++ b/src/input/tests.rs
@@ -7,6 +7,7 @@ use super::{
 };
 use crate::{
     input::ActionKey,
+    input::devices::tracked_device::TrackedDevice,
     openxr_data::{FakeCompositor, Hand, OpenXrData},
     vr::{self, IVRInput010_Interface},
 };
@@ -962,16 +963,20 @@ fn detect_controller_after_manifest_load() {
         input.frame_start_update();
     };
 
+    let devices = f.input.devices.read().unwrap();
+
+    let left_hand = devices.get_controller(Hand::Left.into());
+
     frame();
-    assert!(!f.input.openxr.left_hand.connected());
+    assert!(!left_hand.connected());
 
     f.set_interaction_profile(&Knuckles, fakexr::UserPath::LeftHand);
     frame();
     // Profile won't be set for this frame - we call sync after events have already been polled
-    assert!(!f.input.openxr.left_hand.connected());
+    assert!(!left_hand.connected());
 
     frame();
-    assert!(f.input.openxr.left_hand.connected());
+    assert!(left_hand.connected());
 }
 
 #[test]
diff --git a/src/openxr_data.rs b/src/openxr_data.rs
index 81bac15..dd6ff03 100644
--- a/src/openxr_data.rs
+++ b/src/openxr_data.rs
@@ -1,7 +1,10 @@
 use crate::{
     clientcore::{Injected, Injector},
     graphics_backends::{supported_apis_enum, GraphicsBackend, VulkanData},
-    input::{InteractionProfile, Profiles},
+    input::{
+        devices::tracked_device::{TrackedDevice, TrackedDeviceType},
+        Profiles,
+    },
 };
 use derive_more::Deref;
 use glam::f32::{Quat, Vec3};
@@ -10,8 +13,8 @@ use openvr as vr;
 use openxr as xr;
 use std::mem::ManuallyDrop;
 use std::sync::{
-    atomic::{AtomicBool, AtomicI64, AtomicU64, Ordering},
-    Mutex, RwLock,
+    atomic::{AtomicI64, AtomicU64, Ordering},
+    RwLock,
 };
 
 pub trait Compositor: vr::InterfaceImpl {
@@ -38,8 +41,6 @@ pub struct OpenXrData<C: Compositor> {
     pub system_id: xr::SystemId,
     pub session_data: SessionReadGuard,
     pub display_time: AtomicXrTime,
-    pub left_hand: HandInfo,
-    pub right_hand: HandInfo,
     pub enabled_extensions: xr::ExtensionSet,
 
     /// should only be externally accessed for testing
@@ -119,17 +120,12 @@ impl<C: Compositor> OpenXrData<C> {
             .0,
         )));
 
-        let left_hand = HandInfo::new(&instance, "/user/hand/left");
-        let right_hand = HandInfo::new(&instance, "/user/hand/right");
-
         Ok(Self {
             _entry: entry,
             instance,
             system_id,
             session_data,
             display_time: AtomicXrTime(1.into()),
-            left_hand,
-            right_hand,
             enabled_extensions: exts,
             input: injector.inject(),
             compositor: injector.inject(),
@@ -154,32 +150,52 @@ impl<C: Compositor> OpenXrData<C> {
                     info!("OpenXR session state changed: {:?}", event.state());
                 }
                 xr::Event::InteractionProfileChanged(_) => {
-                    for info in [&self.left_hand, &self.right_hand] {
+                    if self.input.get().is_none() {
+                        continue;
+                    }
+
+                    let xr_input = self.input.get().unwrap();
+
+                    let devices = xr_input.devices.read().unwrap();
+
+                    for hand in [TrackedDeviceType::LeftHand, TrackedDeviceType::RightHand] {
+                        let controller = devices.get_controller(hand);
+                        let hmd = devices.get_hmd();
+
                         let profile_path = session_data
                             .session
-                            .current_interaction_profile(info.subaction_path)
+                            .current_interaction_profile(controller.subaction_path)
                             .unwrap();
 
-                        info.profile_path.store(profile_path);
-                        let profile = match profile_path {
+                        controller
+                            .get_base_device()
+                            .profile_path
+                            .store(profile_path);
+
+                        let profile_name = match profile_path {
                             xr::Path::NULL => {
-                                info.connected.store(false, Ordering::Relaxed);
+                                controller.set_connected(false);
                                 "<null>".to_owned()
                             }
                             path => {
-                                info.connected.store(true, Ordering::Relaxed);
+                                controller.set_connected(true);
                                 self.instance.path_to_string(path).unwrap()
                             }
                         };
 
-                        *info.profile.lock().unwrap() = Profiles::get().profile_from_name(&profile);
+                        let profile = Profiles::get().profile_from_name(&profile_name);
+
+                        if let Some(p) = profile {
+                            controller.set_interaction_profile(p);
+                            hmd.set_interaction_profile(p);
+                        };
 
                         session_data.input_data.interaction_profile_changed();
 
                         info!(
                             "{} interaction profile changed: {}",
-                            info.path_name, profile
-                        );
+                            controller.hand_path, profile_name
+                        )
                     }
                 }
                 _ => {
@@ -608,6 +624,10 @@ impl SessionData {
 
 pub struct AtomicPath(AtomicU64);
 impl AtomicPath {
+    pub(crate) fn new() -> Self {
+        Self(0.into())
+    }
+
     pub(crate) fn load(&self) -> xr::Path {
         xr::Path::from_raw(self.0.load(Ordering::Relaxed))
     }
@@ -617,31 +637,6 @@ impl AtomicPath {
     }
 }
 
-pub struct HandInfo {
-    path_name: &'static str,
-    connected: AtomicBool,
-    pub subaction_path: xr::Path,
-    pub profile_path: AtomicPath,
-    pub profile: Mutex<Option<&'static dyn InteractionProfile>>,
-}
-
-impl HandInfo {
-    #[inline]
-    pub fn connected(&self) -> bool {
-        self.connected.load(Ordering::Relaxed)
-    }
-
-    fn new(instance: &xr::Instance, path_name: &'static str) -> Self {
-        Self {
-            path_name,
-            connected: false.into(),
-            subaction_path: instance.string_to_path(path_name).unwrap(),
-            profile_path: AtomicPath(0.into()),
-            profile: Mutex::default(),
-        }
-    }
-}
-
 #[repr(u32)]
 #[derive(Copy, Clone, Debug, PartialEq)]
 pub enum Hand {
@@ -661,6 +656,13 @@ impl TryFrom<vr::TrackedDeviceIndex_t> for Hand {
     }
 }
 
+impl Into<vr::TrackedDeviceIndex_t> for Hand {
+    #[inline]
+    fn into(self) -> vr::TrackedDeviceIndex_t {
+        self as u32
+    }
+}
+
 /// Taken from: https://github.com/bitshifter/glam-rs/issues/536
 /// Decompose the rotation on to 2 parts.
 ///
diff --git a/src/system.rs b/src/system.rs
index ea1076b..5cbe536 100644
--- a/src/system.rs
+++ b/src/system.rs
@@ -1,6 +1,9 @@
 use crate::{
     clientcore::{Injected, Injector},
-    input::Input,
+    input::{
+        devices::tracked_device::{TrackedDevice, TrackedDeviceType},
+        Input,
+    },
     openxr_data::{Hand, RealOpenXrData, SessionData},
     tracy_span,
 };
@@ -9,16 +12,7 @@ use log::{debug, error, trace, warn};
 use openvr as vr;
 use openxr as xr;
 use std::ffi::CStr;
-use std::sync::{
-    atomic::{AtomicBool, Ordering},
-    Arc, Mutex,
-};
-
-#[derive(Default)]
-struct ConnectedHands {
-    left: AtomicBool,
-    right: AtomicBool,
-}
+use std::sync::{atomic::Ordering, Arc, Mutex};
 
 #[derive(Copy, Clone)]
 pub struct ViewData {
@@ -162,7 +156,6 @@ pub struct System {
     openxr: Arc<RealOpenXrData>, // We don't need to test session restarting.
     input: Injected<Input<crate::compositor::Compositor>>,
     vtables: Vtables,
-    last_connected_hands: ConnectedHands,
     views: Mutex<ViewCache>,
 }
 
@@ -176,7 +169,6 @@ impl System {
             openxr,
             input: injector.inject(),
             vtables: Default::default(),
-            last_connected_hands: Default::default(),
             views: Mutex::default(),
         }
     }
@@ -456,24 +448,25 @@ impl vr::IVRSystem022_Interface for System {
         size: u32,
         pose: *mut vr::TrackedDevicePose_t,
     ) -> bool {
-        for (current, prev, hand) in [
-            (
-                self.openxr.left_hand.connected(),
-                &self.last_connected_hands.left,
-                Hand::Left,
-            ),
-            (
-                self.openxr.right_hand.connected(),
-                &self.last_connected_hands.right,
-                Hand::Right,
-            ),
-        ] {
-            if prev
+        if self.input.get().is_none() {
+            return false;
+        }
+
+        let input = self.input.get().unwrap();
+        let devices = input.devices.read().unwrap();
+
+        for device in devices.iter() {
+            let current = device.connected();
+
+            if device
+                .get_base_device()
+                .previous_connected
                 .compare_exchange(!current, current, Ordering::Relaxed, Ordering::Relaxed)
                 .is_ok()
             {
                 debug!(
-                    "sending {hand:?} {}connected",
+                    "sending {:?} {}connected",
+                    device.get_type(),
                     if current { "" } else { "not " }
                 );
 
@@ -487,13 +480,13 @@ impl vr::IVRSystem022_Interface for System {
                         vr::EVREventType::TrackedDeviceDeactivated as u32
                     });
 
-                    (&raw mut (*event).trackedDeviceIndex).write(hand as u32);
+                    (&raw mut (*event).trackedDeviceIndex).write(device.get_device_index());
                     (&raw mut (*event).eventAgeSeconds).write(0.0);
                     if !pose.is_null() {
                         pose.write(
                             self.input
                                 .force(|_| Input::new(self.openxr.clone()))
-                                .get_controller_pose(hand, Some(origin)),
+                                .get_device_pose(device.get_device_index(), Some(origin)),
                         );
                     }
                 }
@@ -506,7 +499,7 @@ impl vr::IVRSystem022_Interface for System {
             if got_event && !pose.is_null() {
                 unsafe {
                     let index = (&raw const (*event).trackedDeviceIndex).read();
-                    pose.write(input.get_controller_pose(Hand::try_from(index).unwrap(), None));
+                    pose.write(input.get_device_pose(index, None));
                 }
             }
             got_event
@@ -723,62 +716,51 @@ impl vr::IVRSystem022_Interface for System {
     }
 
     fn IsTrackedDeviceConnected(&self, device_index: vr::TrackedDeviceIndex_t) -> bool {
-        match device_index {
-            vr::k_unTrackedDeviceIndex_Hmd => true,
-            x if Hand::try_from(x).is_ok() => match Hand::try_from(x).unwrap() {
-                Hand::Left => self.openxr.left_hand.connected(),
-                Hand::Right => self.openxr.right_hand.connected(),
-            },
-            _ => false,
-        }
+        self.input.get().map_or(false, |input| {
+            input
+                .devices
+                .read()
+                .unwrap()
+                .get_device(device_index)
+                .map_or(false, |device| device.connected())
+        })
     }
 
     fn GetTrackedDeviceClass(&self, index: vr::TrackedDeviceIndex_t) -> vr::ETrackedDeviceClass {
-        match index {
-            vr::k_unTrackedDeviceIndex_Hmd => vr::ETrackedDeviceClass::HMD,
-            x if Hand::try_from(x).is_ok() => {
-                if self.IsTrackedDeviceConnected(x) {
-                    vr::ETrackedDeviceClass::Controller
-                } else {
-                    vr::ETrackedDeviceClass::Invalid
-                }
-            }
-            _ => vr::ETrackedDeviceClass::Invalid,
-        }
+        self.input
+            .get()
+            .map_or(vr::ETrackedDeviceClass::Invalid, |input| {
+                input
+                    .devices
+                    .read()
+                    .unwrap()
+                    .get_device(index)
+                    .map_or(vr::ETrackedDeviceClass::Invalid, |device| {
+                        device.get_type().into()
+                    })
+            })
     }
     fn GetControllerRoleForTrackedDeviceIndex(
         &self,
         index: vr::TrackedDeviceIndex_t,
     ) -> vr::ETrackedControllerRole {
-        match index {
-            x if Hand::try_from(x).is_ok() => match Hand::try_from(x).unwrap() {
-                Hand::Left => vr::ETrackedControllerRole::LeftHand,
-                Hand::Right => vr::ETrackedControllerRole::RightHand,
-            },
-            _ => vr::ETrackedControllerRole::Invalid,
-        }
+        self.input
+            .get()
+            .and_then(|input| {
+                input
+                    .devices
+                    .read()
+                    .unwrap()
+                    .get_device(index)
+                    .and_then(|device| Some(device.get_type().into()))
+            })
+            .unwrap_or(vr::ETrackedControllerRole::Invalid)
     }
     fn GetTrackedDeviceIndexForControllerRole(
         &self,
         role: vr::ETrackedControllerRole,
     ) -> vr::TrackedDeviceIndex_t {
-        match role {
-            vr::ETrackedControllerRole::LeftHand => {
-                if self.openxr.left_hand.connected() {
-                    Hand::Left as u32
-                } else {
-                    vr::k_unTrackedDeviceIndexInvalid
-                }
-            }
-            vr::ETrackedControllerRole::RightHand => {
-                if self.openxr.right_hand.connected() {
-                    Hand::Right as u32
-                } else {
-                    vr::k_unTrackedDeviceIndexInvalid
-                }
-            }
-            _ => vr::k_unTrackedDeviceIndexInvalid,
-        }
+        TrackedDeviceType::from(role).into()
     }
     fn ApplyTransform(
         &self,
@@ -1028,16 +1010,19 @@ impl vr::IVRSystem009On012 for System {
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::clientcore::Injector;
+    use crate::{clientcore::Injector, openxr_data::OpenXrData};
     use std::ffi::CStr;
     use vr::IVRSystem022_Interface;
 
     #[test]
     fn unity_required_properties() {
-        let xr = Arc::new(RealOpenXrData::new(&Injector::default()).unwrap());
+        let xr = Arc::new(OpenXrData::new(&Injector::default()).unwrap());
         let injector = Injector::default();
+        let input = Arc::new(Input::new(xr.clone()));
         let system = System::new(xr, &injector);
 
+        system.input.set(Arc::downgrade(&input));
+
         let test_prop = |property| {
             let mut err = vr::ETrackedPropertyError::Success;
             let len = system.GetStringTrackedDeviceProperty(
-- 
2.51.0


From a224de61c651f1d86d71d83f2b0d7733a6f67650 Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Wed, 19 Mar 2025 18:13:54 +0100
Subject: [PATCH 02/25] cleanup: run cargo fmt

---
 src/input/devices.rs | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/src/input/devices.rs b/src/input/devices.rs
index 8398d01..2bcde46 100644
--- a/src/input/devices.rs
+++ b/src/input/devices.rs
@@ -30,9 +30,7 @@ pub struct TrackedDeviceList {
 impl Default for TrackedDeviceList {
     fn default() -> Self {
         Self {
-            devices: vec![
-                XrHMD::new().into(),
-            ],
+            devices: vec![XrHMD::new().into()],
         }
     }
 }
-- 
2.51.0


From 9c267436ca0815c11f2d8542722621229541458e Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Sun, 23 Mar 2025 20:24:28 +0100
Subject: [PATCH 03/25] cleanup: remove unnecessary device list functions

---
 src/input/devices.rs | 20 +++-----------------
 1 file changed, 3 insertions(+), 17 deletions(-)

diff --git a/src/input/devices.rs b/src/input/devices.rs
index 2bcde46..848ac0b 100644
--- a/src/input/devices.rs
+++ b/src/input/devices.rs
@@ -61,20 +61,6 @@ impl TrackedDeviceList {
         self.devices.get_mut(device_index as usize)
     }
 
-    pub unsafe fn get_device_unchecked(
-        &self,
-        device_index: vr::TrackedDeviceIndex_t,
-    ) -> &TrackedDeviceContainer {
-        self.devices.get_unchecked(device_index as usize)
-    }
-
-    pub unsafe fn get_device_mut_unchecked(
-        &mut self,
-        device_index: vr::TrackedDeviceIndex_t,
-    ) -> &mut TrackedDeviceContainer {
-        self.devices.get_unchecked_mut(device_index as usize)
-    }
-
     /// This function is only intended to be used for the HMD and controllers. For other devices, it'll return the first match.
     pub fn get_device_by_type(
         &self,
@@ -96,7 +82,7 @@ impl TrackedDeviceList {
     }
 
     pub fn get_hmd(&self) -> &XrHMD {
-        let hmd = unsafe { self.get_device_unchecked(0) };
+        let hmd = unsafe { self.devices.get_unchecked(0) };
 
         match hmd {
             TrackedDeviceContainer::HMD(hmd) => hmd,
@@ -106,8 +92,8 @@ impl TrackedDeviceList {
 
     pub fn get_controller(&self, hand: TrackedDeviceType) -> &XrController {
         let controller = match hand {
-            TrackedDeviceType::LeftHand => unsafe { self.get_device_unchecked(1) },
-            TrackedDeviceType::RightHand => unsafe { self.get_device_unchecked(2) },
+            TrackedDeviceType::LeftHand => unsafe { self.devices.get_unchecked(1) },
+            TrackedDeviceType::RightHand => unsafe { self.devices.get_unchecked(2) },
             _ => panic!("Invalid hand type"),
         };
 
-- 
2.51.0


From e1939651d265041133f6defa6e484260df44eb5e Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Sun, 23 Mar 2025 20:30:21 +0100
Subject: [PATCH 04/25] devices: don't hold on to the device index in
 BaseDevice, and remove default impl

---
 src/input/devices/controller.rs     |  2 +-
 src/input/devices/hmd.rs            |  2 +-
 src/input/devices/tracked_device.rs | 30 +++++------------------------
 src/system.rs                       |  6 +++---
 4 files changed, 10 insertions(+), 30 deletions(-)

diff --git a/src/input/devices/controller.rs b/src/input/devices/controller.rs
index 2e73f3a..24827ab 100644
--- a/src/input/devices/controller.rs
+++ b/src/input/devices/controller.rs
@@ -35,7 +35,7 @@ impl XrController {
         let subaction_path = instance.string_to_path(hand_path).unwrap();
 
         Self {
-            base: BaseDevice::new(device_type.into(), device_type),
+            base: BaseDevice::new(device_type),
             hand_path,
             subaction_path,
         }
diff --git a/src/input/devices/hmd.rs b/src/input/devices/hmd.rs
index c72e4d1..af17e16 100644
--- a/src/input/devices/hmd.rs
+++ b/src/input/devices/hmd.rs
@@ -16,7 +16,7 @@ pub struct XrHMD {
 impl XrHMD {
     pub fn new() -> Self {
         let hmd = Self {
-            base: BaseDevice::new(0, TrackedDeviceType::HMD),
+            base: BaseDevice::new(TrackedDeviceType::HMD),
         };
 
         hmd.base.connected.store(true, Ordering::Relaxed);
diff --git a/src/input/devices/tracked_device.rs b/src/input/devices/tracked_device.rs
index ec2caef..813471f 100644
--- a/src/input/devices/tracked_device.rs
+++ b/src/input/devices/tracked_device.rs
@@ -113,10 +113,6 @@ pub trait TrackedDevice {
         self.get_base_device().device_type
     }
 
-    fn get_device_index(&self) -> vr::TrackedDeviceIndex_t {
-        self.get_base_device().device_index
-    }
-
     fn set_interaction_profile(&self, profile: &'static dyn InteractionProfile) {
         self.get_base_device()
             .interaction_profile
@@ -137,32 +133,14 @@ pub trait TrackedDevice {
 
 pub struct BaseDevice {
     pub device_type: TrackedDeviceType,
-    pub device_index: vr::TrackedDeviceIndex_t,
     pub interaction_profile: Mutex<Option<&'static dyn InteractionProfile>>,
     pub profile_path: AtomicPath,
     pub connected: AtomicBool,
     pub previous_connected: AtomicBool,
 }
 
-impl Default for BaseDevice {
-    fn default() -> Self {
-        Self {
-            device_type: TrackedDeviceType::Unknown,
-            device_index: vr::k_unTrackedDeviceIndexInvalid,
-            interaction_profile: Mutex::new(None),
-            profile_path: AtomicPath::new(),
-            connected: AtomicBool::new(false),
-            previous_connected: AtomicBool::new(false),
-        }
-    }
-}
-
 impl BaseDevice {
-    pub fn new(device_index: vr::TrackedDeviceIndex_t, device_type: TrackedDeviceType) -> Self {
-        assert!(
-            device_index != vr::k_unTrackedDeviceIndexInvalid,
-            "Cannot create a device with an invalid index"
-        );
+    pub fn new(device_type: TrackedDeviceType) -> Self {
         assert!(
             device_type != TrackedDeviceType::Unknown,
             "Cannot create a device with an unknown type"
@@ -170,8 +148,10 @@ impl BaseDevice {
 
         Self {
             device_type,
-            device_index,
-            ..Default::default()
+            interaction_profile: Mutex::new(None),
+            profile_path: AtomicPath::new(),
+            connected: AtomicBool::new(false),
+            previous_connected: AtomicBool::new(false),
         }
     }
 }
diff --git a/src/system.rs b/src/system.rs
index 5cbe536..04222c6 100644
--- a/src/system.rs
+++ b/src/system.rs
@@ -455,7 +455,7 @@ impl vr::IVRSystem022_Interface for System {
         let input = self.input.get().unwrap();
         let devices = input.devices.read().unwrap();
 
-        for device in devices.iter() {
+        for (i, device) in devices.iter().enumerate() {
             let current = device.connected();
 
             if device
@@ -480,13 +480,13 @@ impl vr::IVRSystem022_Interface for System {
                         vr::EVREventType::TrackedDeviceDeactivated as u32
                     });
 
-                    (&raw mut (*event).trackedDeviceIndex).write(device.get_device_index());
+                    (&raw mut (*event).trackedDeviceIndex).write(i as vr::TrackedDeviceIndex_t);
                     (&raw mut (*event).eventAgeSeconds).write(0.0);
                     if !pose.is_null() {
                         pose.write(
                             self.input
                                 .force(|_| Input::new(self.openxr.clone()))
-                                .get_device_pose(device.get_device_index(), Some(origin)),
+                                .get_device_pose(i as vr::TrackedDeviceIndex_t, Some(origin)),
                         );
                     }
                 }
-- 
2.51.0


From 139757f90bffa8ca460b76b2e70c5379672b2679 Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Fri, 4 Apr 2025 15:42:40 +0200
Subject: [PATCH 05/25] remove unused enum variant; unpublicize the internal
 device list

---
 src/input/devices.rs                | 2 +-
 src/input/devices/tracked_device.rs | 4 ----
 2 files changed, 1 insertion(+), 5 deletions(-)

diff --git a/src/input/devices.rs b/src/input/devices.rs
index 848ac0b..91a77bf 100644
--- a/src/input/devices.rs
+++ b/src/input/devices.rs
@@ -24,7 +24,7 @@ pub enum TrackedDeviceContainer {
 }
 
 pub struct TrackedDeviceList {
-    pub devices: Vec<TrackedDeviceContainer>,
+    devices: Vec<TrackedDeviceContainer>,
 }
 
 impl Default for TrackedDeviceList {
diff --git a/src/input/devices/tracked_device.rs b/src/input/devices/tracked_device.rs
index 813471f..7ed1fdd 100644
--- a/src/input/devices/tracked_device.rs
+++ b/src/input/devices/tracked_device.rs
@@ -20,7 +20,6 @@ pub enum TrackedDeviceType {
     HMD,
     LeftHand,
     RightHand,
-    GenericTracker,
     Unknown,
 }
 
@@ -30,7 +29,6 @@ impl fmt::Display for TrackedDeviceType {
             Self::HMD => write!(f, "HMD"),
             Self::LeftHand => write!(f, "Left Hand"),
             Self::RightHand => write!(f, "Right Hand"),
-            Self::GenericTracker => write!(f, "Generic Tracker"),
             Self::Unknown => write!(f, "Unknown"),
         }
     }
@@ -42,7 +40,6 @@ impl Into<vr::TrackedDeviceIndex_t> for TrackedDeviceType {
             Self::HMD => vr::k_unTrackedDeviceIndex_Hmd,
             Self::LeftHand => vr::k_unTrackedDeviceIndex_Hmd + 1,
             Self::RightHand => vr::k_unTrackedDeviceIndex_Hmd + 2,
-            Self::GenericTracker => vr::k_unTrackedDeviceIndex_Hmd + 3,
             Self::Unknown => vr::k_unTrackedDeviceIndexInvalid,
         }
     }
@@ -72,7 +69,6 @@ impl Into<vr::ETrackedDeviceClass> for TrackedDeviceType {
         match self {
             Self::HMD => vr::ETrackedDeviceClass::HMD,
             Self::LeftHand | Self::RightHand => vr::ETrackedDeviceClass::Controller,
-            Self::GenericTracker => vr::ETrackedDeviceClass::GenericTracker,
             Self::Unknown => vr::ETrackedDeviceClass::Invalid,
         }
     }
-- 
2.51.0


From 6f6ce25f240cd1ae155ec9e6da4bc10d7adbbc31 Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Fri, 4 Apr 2025 15:44:38 +0200
Subject: [PATCH 06/25] remove Unknown device type

---
 src/input/devices/tracked_device.rs | 11 +----------
 1 file changed, 1 insertion(+), 10 deletions(-)

diff --git a/src/input/devices/tracked_device.rs b/src/input/devices/tracked_device.rs
index 7ed1fdd..cd2f79f 100644
--- a/src/input/devices/tracked_device.rs
+++ b/src/input/devices/tracked_device.rs
@@ -20,7 +20,6 @@ pub enum TrackedDeviceType {
     HMD,
     LeftHand,
     RightHand,
-    Unknown,
 }
 
 impl fmt::Display for TrackedDeviceType {
@@ -29,7 +28,6 @@ impl fmt::Display for TrackedDeviceType {
             Self::HMD => write!(f, "HMD"),
             Self::LeftHand => write!(f, "Left Hand"),
             Self::RightHand => write!(f, "Right Hand"),
-            Self::Unknown => write!(f, "Unknown"),
         }
     }
 }
@@ -40,7 +38,6 @@ impl Into<vr::TrackedDeviceIndex_t> for TrackedDeviceType {
             Self::HMD => vr::k_unTrackedDeviceIndex_Hmd,
             Self::LeftHand => vr::k_unTrackedDeviceIndex_Hmd + 1,
             Self::RightHand => vr::k_unTrackedDeviceIndex_Hmd + 2,
-            Self::Unknown => vr::k_unTrackedDeviceIndexInvalid,
         }
     }
 }
@@ -69,7 +66,6 @@ impl Into<vr::ETrackedDeviceClass> for TrackedDeviceType {
         match self {
             Self::HMD => vr::ETrackedDeviceClass::HMD,
             Self::LeftHand | Self::RightHand => vr::ETrackedDeviceClass::Controller,
-            Self::Unknown => vr::ETrackedDeviceClass::Invalid,
         }
     }
 }
@@ -79,7 +75,7 @@ impl From<vr::ETrackedControllerRole> for TrackedDeviceType {
         match role {
             vr::ETrackedControllerRole::LeftHand => Self::LeftHand,
             vr::ETrackedControllerRole::RightHand => Self::RightHand,
-            _ => Self::Unknown,
+            _ => panic!("Unsupported controller role {:?}", role)
         }
     }
 }
@@ -137,11 +133,6 @@ pub struct BaseDevice {
 
 impl BaseDevice {
     pub fn new(device_type: TrackedDeviceType) -> Self {
-        assert!(
-            device_type != TrackedDeviceType::Unknown,
-            "Cannot create a device with an unknown type"
-        );
-
         Self {
             device_type,
             interaction_profile: Mutex::new(None),
-- 
2.51.0


From 88a4d6f58159038b17453a7314ad834464c067e1 Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Fri, 4 Apr 2025 15:46:42 +0200
Subject: [PATCH 07/25] poll_events: move hmd fetching outside of loop

---
 src/openxr_data.rs | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/openxr_data.rs b/src/openxr_data.rs
index dd6ff03..967b69d 100644
--- a/src/openxr_data.rs
+++ b/src/openxr_data.rs
@@ -157,10 +157,10 @@ impl<C: Compositor> OpenXrData<C> {
                     let xr_input = self.input.get().unwrap();
 
                     let devices = xr_input.devices.read().unwrap();
+                    let hmd = devices.get_hmd();
 
                     for hand in [TrackedDeviceType::LeftHand, TrackedDeviceType::RightHand] {
                         let controller = devices.get_controller(hand);
-                        let hmd = devices.get_hmd();
 
                         let profile_path = session_data
                             .session
-- 
2.51.0


From 69213ba3c802ab8d9b4b97004897b883e2853de9 Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Thu, 10 Apr 2025 02:02:17 +0200
Subject: [PATCH 08/25] move interaction profile changed logic to input

---
 src/input.rs       | 46 +++++++++++++++++++++++++++++++++++++++
 src/openxr_data.rs | 54 +++-------------------------------------------
 2 files changed, 49 insertions(+), 51 deletions(-)

diff --git a/src/input.rs b/src/input.rs
index 70d4c43..7ba4637 100644
--- a/src/input.rs
+++ b/src/input.rs
@@ -10,6 +10,7 @@ pub mod devices;
 mod tests;
 
 use devices::tracked_device::TrackedDevice;
+use devices::tracked_device::TrackedDeviceType;
 use devices::TrackedDeviceList;
 use profiles::MainAxisType;
 pub use profiles::{InteractionProfile, Profiles};
@@ -1304,6 +1305,51 @@ impl<C: openxr_data::Compositor> Input<C> {
         }
     }
 
+    pub fn interaction_profile_changed(&self) {
+        let session = self.openxr.session_data.get();
+        let devices = self.devices.read().unwrap();
+        let hmd = devices.get_hmd();
+
+        for hand in [TrackedDeviceType::LeftHand, TrackedDeviceType::RightHand] {
+            let controller = devices.get_controller(hand);
+
+            let profile_path = session
+                .session
+                .current_interaction_profile(controller.subaction_path)
+                .unwrap();
+
+            controller
+                .get_base_device()
+                .profile_path
+                .store(profile_path);
+
+            let profile_name = match profile_path {
+                xr::Path::NULL => {
+                    controller.set_connected(false);
+                    "<null>".to_owned()
+                }
+                path => {
+                    controller.set_connected(true);
+                    self.openxr.instance.path_to_string(path).unwrap()
+                }
+            };
+
+            let profile = Profiles::get().profile_from_name(&profile_name);
+
+            if let Some(p) = profile {
+                controller.set_interaction_profile(p);
+                hmd.set_interaction_profile(p);
+            };
+
+            session.input_data.interaction_profile_changed();
+
+            info!(
+                "{} interaction profile changed: {}",
+                controller.hand_path, profile_name
+            )
+        }
+    }
+
     pub fn frame_start_update(&self) {
         tracy_span!();
         let data = self.openxr.session_data.get();
diff --git a/src/openxr_data.rs b/src/openxr_data.rs
index 967b69d..a0dbd4f 100644
--- a/src/openxr_data.rs
+++ b/src/openxr_data.rs
@@ -1,10 +1,6 @@
 use crate::{
     clientcore::{Injected, Injector},
     graphics_backends::{supported_apis_enum, GraphicsBackend, VulkanData},
-    input::{
-        devices::tracked_device::{TrackedDevice, TrackedDeviceType},
-        Profiles,
-    },
 };
 use derive_more::Deref;
 use glam::f32::{Quat, Vec3};
@@ -150,52 +146,8 @@ impl<C: Compositor> OpenXrData<C> {
                     info!("OpenXR session state changed: {:?}", event.state());
                 }
                 xr::Event::InteractionProfileChanged(_) => {
-                    if self.input.get().is_none() {
-                        continue;
-                    }
-
-                    let xr_input = self.input.get().unwrap();
-
-                    let devices = xr_input.devices.read().unwrap();
-                    let hmd = devices.get_hmd();
-
-                    for hand in [TrackedDeviceType::LeftHand, TrackedDeviceType::RightHand] {
-                        let controller = devices.get_controller(hand);
-
-                        let profile_path = session_data
-                            .session
-                            .current_interaction_profile(controller.subaction_path)
-                            .unwrap();
-
-                        controller
-                            .get_base_device()
-                            .profile_path
-                            .store(profile_path);
-
-                        let profile_name = match profile_path {
-                            xr::Path::NULL => {
-                                controller.set_connected(false);
-                                "<null>".to_owned()
-                            }
-                            path => {
-                                controller.set_connected(true);
-                                self.instance.path_to_string(path).unwrap()
-                            }
-                        };
-
-                        let profile = Profiles::get().profile_from_name(&profile_name);
-
-                        if let Some(p) = profile {
-                            controller.set_interaction_profile(p);
-                            hmd.set_interaction_profile(p);
-                        };
-
-                        session_data.input_data.interaction_profile_changed();
-
-                        info!(
-                            "{} interaction profile changed: {}",
-                            controller.hand_path, profile_name
-                        )
+                    if let Some(input) = self.input.get() {
+                        input.interaction_profile_changed();
                     }
                 }
                 _ => {
@@ -632,7 +584,7 @@ impl AtomicPath {
         xr::Path::from_raw(self.0.load(Ordering::Relaxed))
     }
 
-    fn store(&self, path: xr::Path) {
+    pub(crate) fn store(&self, path: xr::Path) {
         self.0.store(path.into_raw(), Ordering::Relaxed);
     }
 }
-- 
2.51.0


From 3e7989489288e08b48087e339e15fd312305dbca Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Thu, 10 Apr 2025 17:04:12 +0200
Subject: [PATCH 09/25] cleanup; remove trait impl in favor of one device type

---
 Cargo.lock                           |  13 ---
 Cargo.toml                           |   1 -
 src/input.rs                         | 138 ++++++++++++++++--------
 src/input/action_manifest.rs         |  10 +-
 src/input/action_manifest/helpers.rs |   9 +-
 src/input/devices.rs                 |  83 +++++----------
 src/input/devices/controller.rs      |  80 +++++++-------
 src/input/devices/hmd.rs             |  39 ++-----
 src/input/devices/tracked_device.rs  | 150 ++++++++++-----------------
 src/input/legacy.rs                  |  16 ++-
 src/input/skeletal.rs                |  11 +-
 src/input/tests.rs                   |   1 -
 src/openxr_data.rs                   |  37 ++++++-
 src/system.rs                        | 102 ++++--------------
 14 files changed, 302 insertions(+), 388 deletions(-)

diff --git a/Cargo.lock b/Cargo.lock
index febcc7b..e6a0ec8 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -519,18 +519,6 @@ dependencies = [
  "bytemuck",
 ]
 
-[[package]]
-name = "enum_dispatch"
-version = "0.3.13"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "aa18ce2bc66555b3218614519ac839ddb759a7d6720732f979ef8d13be147ecd"
-dependencies = [
- "once_cell",
- "proc-macro2",
- "quote",
- "syn",
-]
-
 [[package]]
 name = "env_filter"
 version = "0.1.3"
@@ -2711,7 +2699,6 @@ dependencies = [
  "derive_more",
  "egui",
  "egui-miniquad",
- "enum_dispatch",
  "env_logger",
  "fakexr",
  "gl",
diff --git a/Cargo.toml b/Cargo.toml
index df00851..897cdcf 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -36,7 +36,6 @@ workspace = true
 
 [dependencies]
 ash = { workspace = true }
-enum_dispatch = "0.3.13"
 env_logger = "0.11.5"
 glam = { workspace = true }
 log = { workspace = true }
diff --git a/src/input.rs b/src/input.rs
index 7ba4637..12233b0 100644
--- a/src/input.rs
+++ b/src/input.rs
@@ -9,14 +9,13 @@ pub mod devices;
 #[cfg(test)]
 mod tests;
 
-use devices::tracked_device::TrackedDevice;
-use devices::tracked_device::TrackedDeviceType;
 use devices::TrackedDeviceList;
 use profiles::MainAxisType;
 pub use profiles::{InteractionProfile, Profiles};
 use skeletal::FingerState;
 use skeletal::SkeletalInputActionData;
 
+use crate::openxr_data::HandPath;
 use crate::{
     openxr_data::{self, Hand, OpenXrData, SessionData},
     tracy_span, AtomicF32,
@@ -61,8 +60,7 @@ pub struct Input<C: openxr_data::Compositor> {
     estimated_finger_state: [Mutex<FingerState>; 2],
     events: Mutex<VecDeque<InputEvent>>,
     loading_actions: AtomicBool,
-
-    pub devices: RwLock<TrackedDeviceList>,
+    devices: RwLock<TrackedDeviceList>,
 }
 
 struct InputEvent {
@@ -118,8 +116,14 @@ impl<C: openxr_data::Compositor> Input<C> {
             })
             .collect();
 
-        let left_hand = devices.get_controller(Hand::Left.into());
-        let right_hand = devices.get_controller(Hand::Right.into());
+        let left_hand = devices
+            .get_controller(Hand::Left)
+            .get_controller_variables()
+            .unwrap();
+        let right_hand = devices
+            .get_controller(Hand::Right)
+            .get_controller_variables()
+            .unwrap();
 
         let pose_data = PoseData::new(
             &openxr.instance,
@@ -162,8 +166,12 @@ impl<C: openxr_data::Compositor> Input<C> {
         } else {
             let devices = self.devices.read().ok()?;
 
-            let left_hand = devices.get_controller(Hand::Left.into());
-            let right_hand = devices.get_controller(Hand::Right.into());
+            let left_hand = devices
+                .get_controller(Hand::Left)
+                .get_controller_variables()?;
+            let right_hand = devices
+                .get_controller(Hand::Right)
+                .get_controller_variables()?;
 
             match InputSourceKey::from(KeyData::from_ffi(handle)) {
                 x if x == self.left_hand_key => Some(left_hand.subaction_path),
@@ -766,33 +774,31 @@ impl<C: openxr_data::Compositor> vr::IVRInput010_Interface for Input<C> {
         let subaction_path = get_subaction_path!(self, restrict_to_device, action_data);
         let devices = self.devices.read().unwrap();
 
-        let left_hand = devices.get_controller(Hand::Left.into());
-        let right_hand = devices.get_controller(Hand::Right.into());
+        let left_hand = devices.get_controller(Hand::Left);
+        let right_hand = devices.get_controller(Hand::Right);
 
         let (active_origin, hand) = match loaded.try_get_action(action) {
             Ok(ActionData::Pose) => {
                 let (mut hand, interaction_profile) = match subaction_path {
-                    x if x == left_hand.subaction_path => (
-                        Some(Hand::Left),
-                        Some(left_hand.get_base_device().profile_path.load()),
-                    ),
-                    x if x == right_hand.subaction_path => (
-                        Some(Hand::Right),
-                        Some(right_hand.get_base_device().profile_path.load()),
-                    ),
+                    x if x == left_hand.get_controller_variables().unwrap().subaction_path => {
+                        (Some(Hand::Left), Some(left_hand.profile_path.load()))
+                    }
+                    x if x
+                        == right_hand
+                            .get_controller_variables()
+                            .unwrap()
+                            .subaction_path =>
+                    {
+                        (Some(Hand::Right), Some(right_hand.profile_path.load()))
+                    }
                     x if x == xr::Path::NULL => (None, None),
                     _ => unreachable!(),
                 };
 
                 let get_first_bound_hand_profile = || {
                     loaded
-                        .try_get_pose(action, left_hand.get_base_device().profile_path.load())
-                        .or_else(|_| {
-                            loaded.try_get_pose(
-                                action,
-                                right_hand.get_base_device().profile_path.load(),
-                            )
-                        })
+                        .try_get_pose(action, left_hand.profile_path.load())
+                        .or_else(|_| loaded.try_get_pose(action, right_hand.profile_path.load()))
                         .ok()
                 };
 
@@ -1077,8 +1083,8 @@ impl<C: openxr_data::Compositor> vr::IVRInput010_Interface for Input<C> {
         let left_hand = devices.get_controller(Hand::Left.into());
         let right_hand = devices.get_controller(Hand::Right.into());
 
-        let left_profile = left_hand.get_base_device().profile_path.load();
-        let right_profile = right_hand.get_base_device().profile_path.load();
+        let left_profile = left_hand.profile_path.load();
+        let right_profile = right_hand.profile_path.load();
         for key in &actions.actions_with_custom_bindings {
             let unsync_custom_bindings = |key, profile| {
                 if profile == xr::Path::NULL {
@@ -1305,23 +1311,33 @@ impl<C: openxr_data::Compositor> Input<C> {
         }
     }
 
+    pub fn is_device_connected(&self, index: vr::TrackedDeviceIndex_t) -> bool {
+        let Some(devices) = self.devices.read().ok() else {
+            return false;
+        };
+
+        let Some(device) = devices.get_device(index) else {
+            return false;
+        };
+
+        device.connected()
+    }
+
     pub fn interaction_profile_changed(&self) {
         let session = self.openxr.session_data.get();
         let devices = self.devices.read().unwrap();
         let hmd = devices.get_hmd();
 
-        for hand in [TrackedDeviceType::LeftHand, TrackedDeviceType::RightHand] {
+        for hand in [Hand::Left, Hand::Right] {
             let controller = devices.get_controller(hand);
+            let vars = controller.get_controller_variables().unwrap();
 
             let profile_path = session
                 .session
-                .current_interaction_profile(controller.subaction_path)
+                .current_interaction_profile(vars.subaction_path)
                 .unwrap();
 
-            controller
-                .get_base_device()
-                .profile_path
-                .store(profile_path);
+            controller.profile_path.store(profile_path);
 
             let profile_name = match profile_path {
                 xr::Path::NULL => {
@@ -1345,7 +1361,8 @@ impl<C: openxr_data::Compositor> Input<C> {
 
             info!(
                 "{} interaction profile changed: {}",
-                controller.hand_path, profile_name
+                HandPath::from(vars.hand),
+                profile_name
             )
         }
     }
@@ -1357,8 +1374,8 @@ impl<C: openxr_data::Compositor> Input<C> {
         if let Some(loaded) = input_data.get_loaded_actions() {
             let devices = self.devices.read().unwrap();
 
-            let left_hand = devices.get_controller(Hand::Left.into());
-            let right_hand = devices.get_controller(Hand::Right.into());
+            let left_hand = devices.get_controller(Hand::Left);
+            let right_hand = devices.get_controller(Hand::Right);
 
             // If the game has loaded actions, we shouldn't need to sync the state because the game
             // should be doing it itself with UpdateActionState. However, some games (Tea for God)
@@ -1420,7 +1437,6 @@ impl<C: openxr_data::Compositor> Input<C> {
             .read()
             .ok()?
             .get_device(hand.into())?
-            .get_base_device()
             .profile_path
             .load();
 
@@ -1501,8 +1517,15 @@ impl<C: openxr_data::Compositor> Input<C> {
 
     pub fn post_session_restart(&self, data: &SessionData) {
         let devices = self.devices.read().unwrap();
-        let left_hand = devices.get_controller(Hand::Left.into());
-        let right_hand = devices.get_controller(Hand::Right.into());
+
+        let left_hand = devices
+            .get_controller(Hand::Left)
+            .get_controller_variables()
+            .unwrap();
+        let right_hand = devices
+            .get_controller(Hand::Right)
+            .get_controller_variables()
+            .unwrap();
 
         // This function is called while a write lock is called on the session, and as such should
         // not use self.openxr.session_data.get().
@@ -1526,6 +1549,39 @@ impl<C: openxr_data::Compositor> Input<C> {
             return false;
         }
 
+        let devices = self.devices.read().unwrap();
+
+        for (i, device) in devices.iter().enumerate() {
+            let current = device.connected();
+
+            if device
+                .previous_connected
+                .compare_exchange(!current, current, Ordering::Relaxed, Ordering::Relaxed)
+                .is_ok()
+            {
+                debug!(
+                    "sending {:?} {}connected",
+                    device.get_type(),
+                    if current { "" } else { "not " }
+                );
+
+                // VREvent_t can be different sizes depending on the OpenVR version,
+                // so we use raw pointers to avoid creating a reference, because if the
+                // size doesn't match our VREvent_t's size, we are in UB land
+                unsafe {
+                    (&raw mut (*out).eventType).write(if current {
+                        vr::EVREventType::TrackedDeviceActivated as u32
+                    } else {
+                        vr::EVREventType::TrackedDeviceDeactivated as u32
+                    });
+
+                    (&raw mut (*out).trackedDeviceIndex).write(i as vr::TrackedDeviceIndex_t);
+                    (&raw mut (*out).eventAgeSeconds).write(0.0);
+                }
+                return true;
+            }
+        }
+
         if let Some(event) = self.events.lock().unwrap().pop_front() {
             const MIN_CONTROLLER_EVENT_SIZE: usize = std::mem::offset_of!(vr::VREvent_t, data)
                 + std::mem::size_of::<vr::VREvent_Controller_t>();
@@ -1533,9 +1589,7 @@ impl<C: openxr_data::Compositor> Input<C> {
                 warn!("{FUNC}: Provided event struct size ({size}) is smaller than required ({MIN_CONTROLLER_EVENT_SIZE}).");
                 return false;
             }
-            // VREvent_t can be different sizes depending on the OpenVR version,
-            // so we use raw pointers to avoid creating a reference, because if the
-            // size doesn't match our VREvent_t's size, we are in UB land
+
             unsafe {
                 (&raw mut (*out).eventType).write(event.ty as u32);
                 (&raw mut (*out).trackedDeviceIndex).write(event.index);
diff --git a/src/input/action_manifest.rs b/src/input/action_manifest.rs
index 5d2dfe2..30d15ca 100644
--- a/src/input/action_manifest.rs
+++ b/src/input/action_manifest.rs
@@ -100,8 +100,14 @@ impl<C: openxr_data::Compositor> Input<C> {
         debug!("Loaded {} action sets.", sets.len());
 
         let devices = self.devices.read().unwrap();
-        let left_hand = devices.get_controller(Hand::Left.into());
-        let right_hand = devices.get_controller(Hand::Right.into());
+        let left_hand = devices
+            .get_controller(Hand::Left)
+            .get_controller_variables()
+            .ok_or(vr::EVRInputError::InvalidDevice)?;
+        let right_hand = devices
+            .get_controller(Hand::Right)
+            .get_controller_variables()
+            .ok_or(vr::EVRInputError::InvalidDevice)?;
 
         let actions = load_actions(
             &self.openxr.instance,
diff --git a/src/input/action_manifest/helpers.rs b/src/input/action_manifest/helpers.rs
index 1816c55..6bd04f0 100644
--- a/src/input/action_manifest/helpers.rs
+++ b/src/input/action_manifest/helpers.rs
@@ -58,10 +58,13 @@ impl BindingsLoadContext<'_> {
             return None;
         };
 
-        let left_hand = devices.get_controller(Hand::Left.into());
-        let right_hand = devices.get_controller(Hand::Right.into());
+        let left_hand = devices.get_controller(Hand::Left);
+        let right_hand = devices.get_controller(Hand::Right);
 
-        let hands = [left_hand.subaction_path, right_hand.subaction_path];
+        let hands = [
+            left_hand.get_controller_variables()?.subaction_path,
+            right_hand.get_controller_variables()?.subaction_path,
+        ];
 
         let bindings_parsed = self
             .per_profile_bindings
diff --git a/src/input/devices.rs b/src/input/devices.rs
index 91a77bf..c7556fb 100644
--- a/src/input/devices.rs
+++ b/src/input/devices.rs
@@ -1,38 +1,17 @@
-use controller::XrController;
-use enum_dispatch::enum_dispatch;
-use hmd::XrHMD;
-use tracked_device::{BaseDevice, TrackedDevice, TrackedDeviceType};
+use controller::ControllerVariables;
+use tracked_device::{TrackedDeviceType, XrTrackedDevice};
 
 use openvr as vr;
 use openxr as xr;
 
-use crate::{
-    input::InteractionProfile,
-    openxr_data::{OpenXrData, SessionData},
-};
+use crate::openxr_data::Hand;
 
-pub mod controller;
-pub mod hmd;
+mod controller;
+mod hmd;
 pub mod tracked_device;
 
-// enum dispatch generates the trait implementation for this enum,
-// so we can access the methods of the variants without having to match anything manually.
-#[enum_dispatch(TrackedDevice)]
-pub enum TrackedDeviceContainer {
-    HMD(XrHMD),
-    Controller(XrController),
-}
-
 pub struct TrackedDeviceList {
-    devices: Vec<TrackedDeviceContainer>,
-}
-
-impl Default for TrackedDeviceList {
-    fn default() -> Self {
-        Self {
-            devices: vec![XrHMD::new().into()],
-        }
-    }
+    devices: Vec<XrTrackedDevice>,
 }
 
 #[allow(dead_code)]
@@ -40,32 +19,32 @@ impl TrackedDeviceList {
     pub fn new(xr_instance: &xr::Instance) -> Self {
         Self {
             devices: vec![
-                XrHMD::new().into(),
-                XrController::new(xr_instance, TrackedDeviceType::LeftHand).into(),
-                XrController::new(xr_instance, TrackedDeviceType::RightHand).into(),
+                XrTrackedDevice::new(TrackedDeviceType::Hmd),
+                XrTrackedDevice::new(TrackedDeviceType::Controller(ControllerVariables::new(
+                    xr_instance,
+                    Hand::Left,
+                ))),
+                XrTrackedDevice::new(TrackedDeviceType::Controller(ControllerVariables::new(
+                    xr_instance,
+                    Hand::Right,
+                ))),
             ],
         }
     }
 
-    pub fn get_device(
-        &self,
-        device_index: vr::TrackedDeviceIndex_t,
-    ) -> Option<&TrackedDeviceContainer> {
+    pub fn get_device(&self, device_index: vr::TrackedDeviceIndex_t) -> Option<&XrTrackedDevice> {
         self.devices.get(device_index as usize)
     }
 
     pub fn get_device_mut(
         &mut self,
         device_index: vr::TrackedDeviceIndex_t,
-    ) -> Option<&mut TrackedDeviceContainer> {
+    ) -> Option<&mut XrTrackedDevice> {
         self.devices.get_mut(device_index as usize)
     }
 
     /// This function is only intended to be used for the HMD and controllers. For other devices, it'll return the first match.
-    pub fn get_device_by_type(
-        &self,
-        device_type: TrackedDeviceType,
-    ) -> Option<&TrackedDeviceContainer> {
+    pub fn get_device_by_type(&self, device_type: TrackedDeviceType) -> Option<&XrTrackedDevice> {
         self.devices
             .iter()
             .find(|device| device.get_type() == device_type)
@@ -75,35 +54,21 @@ impl TrackedDeviceList {
     pub fn get_device_by_type_mut(
         &mut self,
         device_type: TrackedDeviceType,
-    ) -> Option<&mut TrackedDeviceContainer> {
+    ) -> Option<&mut XrTrackedDevice> {
         self.devices
             .iter_mut()
             .find(|device| device.get_type() == device_type)
     }
 
-    pub fn get_hmd(&self) -> &XrHMD {
-        let hmd = unsafe { self.devices.get_unchecked(0) };
-
-        match hmd {
-            TrackedDeviceContainer::HMD(hmd) => hmd,
-            _ => panic!("HMD is not the first device in the list"),
-        }
+    pub fn get_hmd(&self) -> &XrTrackedDevice {
+        unsafe { self.devices.get_unchecked(0) }
     }
 
-    pub fn get_controller(&self, hand: TrackedDeviceType) -> &XrController {
-        let controller = match hand {
-            TrackedDeviceType::LeftHand => unsafe { self.devices.get_unchecked(1) },
-            TrackedDeviceType::RightHand => unsafe { self.devices.get_unchecked(2) },
-            _ => panic!("Invalid hand type"),
-        };
-
-        match controller {
-            TrackedDeviceContainer::Controller(controller) => controller,
-            _ => panic!("Controller is not the second or third device in the list"),
-        }
+    pub fn get_controller(&self, hand: Hand) -> &XrTrackedDevice {
+        unsafe { self.devices.get_unchecked(hand as usize) }
     }
 
-    pub fn iter(&self) -> std::slice::Iter<'_, TrackedDeviceContainer> {
+    pub fn iter(&self) -> std::slice::Iter<'_, XrTrackedDevice> {
         self.devices.iter()
     }
 
diff --git a/src/input/devices/controller.rs b/src/input/devices/controller.rs
index 24827ab..854a80e 100644
--- a/src/input/devices/controller.rs
+++ b/src/input/devices/controller.rs
@@ -1,61 +1,51 @@
-use super::tracked_device::{BaseDevice, TrackedDevice};
-
-use log::trace;
-use openvr::{self as vr, space_relation_to_openvr_pose};
+use openvr as vr;
 use openxr as xr;
 
-use crate::{
-    input::devices::tracked_device::TrackedDeviceType,
-    openxr_data::{OpenXrData, SessionData},
-    tracy_span,
-};
+use crate::openxr_data::{Hand, OpenXrData, SessionData};
 
-pub struct XrController {
-    base: BaseDevice,
+use super::tracked_device::{TrackedDeviceType, XrTrackedDevice};
 
-    pub hand_path: &'static str,
+use log::trace;
+
+#[derive(Debug, Copy, Clone, PartialEq)]
+pub struct ControllerVariables {
+    pub hand: Hand,
     pub subaction_path: xr::Path,
 }
 
-impl XrController {
-    pub fn new(instance: &xr::Instance, device_type: TrackedDeviceType) -> Self {
-        assert!(
-            device_type == TrackedDeviceType::LeftHand
-                || device_type == TrackedDeviceType::RightHand,
-            "Invalid device type \"{}\" for controller",
-            device_type
-        );
-
-        let hand_path = match device_type {
-            TrackedDeviceType::LeftHand => "/user/hand/left",
-            TrackedDeviceType::RightHand => "/user/hand/right",
-            _ => unreachable!(),
-        };
-
-        let subaction_path = instance.string_to_path(hand_path).unwrap();
-
+impl Default for ControllerVariables {
+    fn default() -> Self {
         Self {
-            base: BaseDevice::new(device_type),
-            hand_path,
-            subaction_path,
+            hand: Hand::Left,
+            subaction_path: xr::Path::default(),
         }
     }
 }
 
-impl TrackedDevice for XrController {
-    fn get_pose(
+impl ControllerVariables {
+    pub fn new(instance: &xr::Instance, hand: Hand) -> Self {
+
+        Self {
+            hand,
+            subaction_path: match hand {
+                Hand::Left => instance.string_to_path(hand.into()).unwrap(),
+                Hand::Right => instance.string_to_path(hand.into()).unwrap(),
+            },
+        }
+    }
+}
+
+impl XrTrackedDevice {
+    pub fn get_controller_pose(
         &self,
         xr_data: &OpenXrData<impl crate::openxr_data::Compositor>,
         session_data: &SessionData,
         origin: vr::ETrackingUniverseOrigin,
     ) -> Option<vr::TrackedDevicePose_t> {
-        tracy_span!("XrController::get_pose");
-
         let pose_data = session_data.input_data.pose_data.get().unwrap();
-        let space = match self.get_type() {
-            TrackedDeviceType::LeftHand => &pose_data.left_space,
-            TrackedDeviceType::RightHand => &pose_data.right_space,
-            _ => return None,
+        let space = match self.get_controller_variables()?.hand {
+            Hand::Left => &pose_data.left_space,
+            Hand::Right => &pose_data.right_space,
         };
 
         let (location, velocity) = if let Some(raw) = space.try_get_or_init_raw(
@@ -73,10 +63,14 @@ impl TrackedDevice for XrController {
             (xr::SpaceLocation::default(), xr::SpaceVelocity::default())
         };
 
-        Some(space_relation_to_openvr_pose(location, velocity))
+        Some(vr::space_relation_to_openvr_pose(location, velocity))
     }
 
-    fn get_base_device(&self) -> &BaseDevice {
-        &self.base
+    pub fn get_controller_variables(&self) -> Option<ControllerVariables> {
+        if let TrackedDeviceType::Controller(vars) = self.device_type {
+            Some(vars)
+        } else {
+            None
+        }
     }
 }
diff --git a/src/input/devices/hmd.rs b/src/input/devices/hmd.rs
index af17e16..a50ec20 100644
--- a/src/input/devices/hmd.rs
+++ b/src/input/devices/hmd.rs
@@ -1,39 +1,16 @@
-use std::sync::atomic::Ordering;
+use openvr as vr;
 
-use super::tracked_device::{BaseDevice, TrackedDevice, TrackedDeviceType};
+use crate::openxr_data::{OpenXrData, SessionData};
 
-use openvr::{self as vr, space_relation_to_openvr_pose};
+use super::tracked_device::XrTrackedDevice;
 
-use crate::{
-    openxr_data::{OpenXrData, SessionData},
-    tracy_span,
-};
-
-pub struct XrHMD {
-    base: BaseDevice,
-}
-
-impl XrHMD {
-    pub fn new() -> Self {
-        let hmd = Self {
-            base: BaseDevice::new(TrackedDeviceType::HMD),
-        };
-
-        hmd.base.connected.store(true, Ordering::Relaxed);
-
-        hmd
-    }
-}
-
-impl TrackedDevice for XrHMD {
-    fn get_pose(
+impl XrTrackedDevice {
+    pub fn get_hmd_pose(
         &self,
         xr_data: &OpenXrData<impl crate::openxr_data::Compositor>,
         session_data: &SessionData,
         origin: vr::ETrackingUniverseOrigin,
     ) -> Option<vr::TrackedDevicePose_t> {
-        tracy_span!("XrHMD::get_pose");
-
         let (location, velocity) = {
             session_data
                 .view_space
@@ -44,10 +21,6 @@ impl TrackedDevice for XrHMD {
                 .ok()?
         };
 
-        Some(space_relation_to_openvr_pose(location, velocity))
-    }
-
-    fn get_base_device(&self) -> &BaseDevice {
-        &self.base
+        Some(vr::space_relation_to_openvr_pose(location, velocity))
     }
 }
diff --git a/src/input/devices/tracked_device.rs b/src/input/devices/tracked_device.rs
index cd2f79f..d8cbac0 100644
--- a/src/input/devices/tracked_device.rs
+++ b/src/input/devices/tracked_device.rs
@@ -6,7 +6,6 @@ use std::{
     },
 };
 
-use enum_dispatch::enum_dispatch;
 use openvr as vr;
 
 use crate::{
@@ -14,116 +13,41 @@ use crate::{
     openxr_data::{AtomicPath, Hand, OpenXrData, SessionData},
 };
 
+use super::controller::ControllerVariables;
+
 #[derive(Debug, Copy, Clone, PartialEq)]
 #[allow(dead_code)]
 pub enum TrackedDeviceType {
-    HMD,
-    LeftHand,
-    RightHand,
+    Hmd,
+    Controller(ControllerVariables),
 }
 
 impl fmt::Display for TrackedDeviceType {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         match self {
-            Self::HMD => write!(f, "HMD"),
-            Self::LeftHand => write!(f, "Left Hand"),
-            Self::RightHand => write!(f, "Right Hand"),
+            Self::Hmd => write!(f, "HMD"),
+            Self::Controller(vars) => match vars.hand {
+                Hand::Left => write!(f, "Left Hand"),
+                Hand::Right => write!(f, "Right Hand"),
+            },
         }
     }
 }
 
-impl Into<vr::TrackedDeviceIndex_t> for TrackedDeviceType {
-    fn into(self) -> vr::TrackedDeviceIndex_t {
-        match self {
-            Self::HMD => vr::k_unTrackedDeviceIndex_Hmd,
-            Self::LeftHand => vr::k_unTrackedDeviceIndex_Hmd + 1,
-            Self::RightHand => vr::k_unTrackedDeviceIndex_Hmd + 2,
+impl TryFrom<vr::TrackedDeviceIndex_t> for TrackedDeviceType {
+    type Error = ();
+
+    fn try_from(value: vr::TrackedDeviceIndex_t) -> Result<Self, Self::Error> {
+        match value {
+            0 => Ok(Self::Hmd),
+            1 => Ok(Self::Controller(ControllerVariables::default())),
+            2 => Ok(Self::Controller(ControllerVariables::default())),
+            _ => Err(()),
         }
     }
 }
 
-impl From<Hand> for TrackedDeviceType {
-    fn from(hand: Hand) -> Self {
-        match hand {
-            Hand::Left => Self::LeftHand,
-            Hand::Right => Self::RightHand,
-        }
-    }
-}
-
-impl Into<vr::ETrackedControllerRole> for TrackedDeviceType {
-    fn into(self) -> vr::ETrackedControllerRole {
-        match self {
-            Self::LeftHand => vr::ETrackedControllerRole::LeftHand,
-            Self::RightHand => vr::ETrackedControllerRole::RightHand,
-            _ => vr::ETrackedControllerRole::Invalid,
-        }
-    }
-}
-
-impl Into<vr::ETrackedDeviceClass> for TrackedDeviceType {
-    fn into(self) -> vr::ETrackedDeviceClass {
-        match self {
-            Self::HMD => vr::ETrackedDeviceClass::HMD,
-            Self::LeftHand | Self::RightHand => vr::ETrackedDeviceClass::Controller,
-        }
-    }
-}
-
-impl From<vr::ETrackedControllerRole> for TrackedDeviceType {
-    fn from(role: vr::ETrackedControllerRole) -> Self {
-        match role {
-            vr::ETrackedControllerRole::LeftHand => Self::LeftHand,
-            vr::ETrackedControllerRole::RightHand => Self::RightHand,
-            _ => panic!("Unsupported controller role {:?}", role)
-        }
-    }
-}
-
-#[enum_dispatch]
-pub trait TrackedDevice {
-    fn get_pose(
-        &self,
-        xr_data: &OpenXrData<impl crate::openxr_data::Compositor>,
-        session_data: &SessionData,
-        origin: vr::ETrackingUniverseOrigin,
-    ) -> Option<vr::TrackedDevicePose_t>;
-
-    fn get_base_device(&self) -> &BaseDevice;
-
-    fn connected(&self) -> bool {
-        self.get_base_device().connected.load(Ordering::Relaxed)
-    }
-
-    fn set_connected(&self, connected: bool) {
-        self.get_base_device()
-            .connected
-            .store(connected, Ordering::Relaxed);
-    }
-
-    fn get_type(&self) -> TrackedDeviceType {
-        self.get_base_device().device_type
-    }
-
-    fn set_interaction_profile(&self, profile: &'static dyn InteractionProfile) {
-        self.get_base_device()
-            .interaction_profile
-            .lock()
-            .unwrap()
-            .replace(profile);
-    }
-
-    fn get_interaction_profile(&self) -> Option<&'static dyn InteractionProfile> {
-        self.get_base_device()
-            .interaction_profile
-            .lock()
-            .unwrap()
-            .as_ref()
-            .copied()
-    }
-}
-
-pub struct BaseDevice {
+pub struct XrTrackedDevice {
     pub device_type: TrackedDeviceType,
     pub interaction_profile: Mutex<Option<&'static dyn InteractionProfile>>,
     pub profile_path: AtomicPath,
@@ -131,7 +55,7 @@ pub struct BaseDevice {
     pub previous_connected: AtomicBool,
 }
 
-impl BaseDevice {
+impl XrTrackedDevice {
     pub fn new(device_type: TrackedDeviceType) -> Self {
         Self {
             device_type,
@@ -141,4 +65,38 @@ impl BaseDevice {
             previous_connected: AtomicBool::new(false),
         }
     }
+
+    pub fn get_pose(
+        &self,
+        xr_data: &OpenXrData<impl crate::openxr_data::Compositor>,
+        session_data: &SessionData,
+        origin: vr::ETrackingUniverseOrigin,
+    ) -> Option<vr::TrackedDevicePose_t> {
+        match self.device_type {
+            TrackedDeviceType::Hmd => self.get_hmd_pose(xr_data, session_data, origin),
+            TrackedDeviceType::Controller { .. } => {
+                self.get_controller_pose(xr_data, session_data, origin)
+            }
+        }
+    }
+
+    pub fn connected(&self) -> bool {
+        self.connected.load(Ordering::Relaxed)
+    }
+
+    pub fn set_connected(&self, connected: bool) {
+        self.connected.store(connected, Ordering::Relaxed);
+    }
+
+    pub fn get_type(&self) -> TrackedDeviceType {
+        self.device_type
+    }
+
+    pub fn set_interaction_profile(&self, profile: &'static dyn InteractionProfile) {
+        self.interaction_profile.lock().unwrap().replace(profile);
+    }
+
+    pub fn get_interaction_profile(&self) -> Option<&'static dyn InteractionProfile> {
+        self.interaction_profile.lock().unwrap().as_ref().copied()
+    }
 }
diff --git a/src/input/legacy.rs b/src/input/legacy.rs
index 31c60cb..3f8976c 100644
--- a/src/input/legacy.rs
+++ b/src/input/legacy.rs
@@ -47,8 +47,11 @@ impl<C: openxr_data::Compositor> Input<C> {
 
         let legacy = LegacyActionData::new(
             &self.openxr.instance,
-            left_hand.subaction_path,
-            right_hand.subaction_path,
+            left_hand.get_controller_variables().unwrap().subaction_path,
+            right_hand
+                .get_controller_variables()
+                .unwrap()
+                .subaction_path,
         );
         let input_data = &session_data.input_data;
 
@@ -109,7 +112,9 @@ impl<C: openxr_data::Compositor> Input<C> {
         };
         let devices = self.devices.read().unwrap();
         let controller = devices.get_controller(hand.into());
-        let hand_path = controller.subaction_path;
+        let hand_path = controller.get_controller_variables()
+            .unwrap()
+            .subaction_path;
 
         let Some(legacy) = data.input_data.get_legacy_actions() else {
             debug!("tried triggering haptic, but legacy actions aren't ready");
@@ -176,7 +181,10 @@ impl<C: openxr_data::Compositor> Input<C> {
 
         let devices = self.devices.read().unwrap();
 
-        let controller = devices.get_controller(hand.into());
+        let Some(controller) = devices.get_controller(hand).get_controller_variables() else {
+            debug!("tried getting controller state, but no controller variables were found");
+            return false;
+        };
 
         let hand_path = controller.subaction_path;
 
diff --git a/src/input/skeletal.rs b/src/input/skeletal.rs
index a14f471..a72ef0b 100644
--- a/src/input/skeletal.rs
+++ b/src/input/skeletal.rs
@@ -2,7 +2,6 @@
 mod gen;
 
 use super::Input;
-use crate::input::devices::tracked_device::TrackedDevice;
 use crate::openxr_data::{self, Hand, SessionData};
 use glam::{Affine3A, Quat, Vec3};
 use log::debug;
@@ -30,7 +29,7 @@ impl<C: openxr_data::Compositor> Input<C> {
         let display_time = self.openxr.display_time.get();
         let devices = self.devices.read().unwrap();
 
-        let controller = devices.get_controller(hand.into());
+        let controller = devices.get_controller(hand);
 
         let Some(raw) = match hand {
             Hand::Left => &pose_data.left_space,
@@ -179,7 +178,7 @@ impl<C: openxr_data::Compositor> Input<C> {
         let display_time = self.openxr.display_time.get();
         let devices = self.devices.read().unwrap();
 
-        let controller = devices.get_controller(hand.into());
+        let controller = devices.get_controller(hand);
 
         let Some(raw) = match hand {
             Hand::Left => &pose_data.left_space,
@@ -352,7 +351,11 @@ impl<C: openxr_data::Compositor> Input<C> {
 
         let devices = self.devices.read().unwrap();
 
-        let subaction = devices.get_controller(hand.into()).subaction_path;
+        let subaction = devices
+            .get_controller(hand)
+            .get_controller_variables()
+            .unwrap()
+            .subaction_path;
 
         let thumb_touch = actions
             .thumb_touch
diff --git a/src/input/tests.rs b/src/input/tests.rs
index 97bd3cc..fd46f5a 100644
--- a/src/input/tests.rs
+++ b/src/input/tests.rs
@@ -7,7 +7,6 @@ use super::{
 };
 use crate::{
     input::ActionKey,
-    input::devices::tracked_device::TrackedDevice,
     openxr_data::{FakeCompositor, Hand, OpenXrData},
     vr::{self, IVRInput010_Interface},
 };
diff --git a/src/openxr_data.rs b/src/openxr_data.rs
index a0dbd4f..52cb6e3 100644
--- a/src/openxr_data.rs
+++ b/src/openxr_data.rs
@@ -596,6 +596,17 @@ pub enum Hand {
     Right,
 }
 
+pub type HandPath = &'static str;
+
+impl From<Hand> for HandPath {
+    fn from(value: Hand) -> Self {
+        match value {
+            Hand::Left => "/user/hand/left",
+            Hand::Right => "/user/hand/right",
+        }
+    }
+}
+
 impl TryFrom<vr::TrackedDeviceIndex_t> for Hand {
     type Error = ();
     #[inline]
@@ -608,10 +619,30 @@ impl TryFrom<vr::TrackedDeviceIndex_t> for Hand {
     }
 }
 
-impl Into<vr::TrackedDeviceIndex_t> for Hand {
+impl TryFrom<vr::ETrackedControllerRole> for Hand {
+    type Error = ();
     #[inline]
-    fn into(self) -> vr::TrackedDeviceIndex_t {
-        self as u32
+    fn try_from(value: vr::ETrackedControllerRole) -> Result<Self, Self::Error> {
+        match value {
+            vr::ETrackedControllerRole::LeftHand => Ok(Hand::Left),
+            vr::ETrackedControllerRole::RightHand => Ok(Hand::Right),
+            _ => Err(()),
+        }
+    }
+}
+
+impl From<Hand> for vr::TrackedDeviceIndex_t {
+    fn from(hand: Hand) -> Self {
+        hand as vr::TrackedDeviceIndex_t
+    }
+}
+
+impl From<Hand> for vr::ETrackedControllerRole {
+    fn from(hand: Hand) -> Self {
+        match hand {
+            Hand::Left => vr::ETrackedControllerRole::LeftHand,
+            Hand::Right => vr::ETrackedControllerRole::RightHand,
+        }
     }
 }
 
diff --git a/src/system.rs b/src/system.rs
index 04222c6..439ab49 100644
--- a/src/system.rs
+++ b/src/system.rs
@@ -1,9 +1,6 @@
 use crate::{
     clientcore::{Injected, Injector},
-    input::{
-        devices::tracked_device::{TrackedDevice, TrackedDeviceType},
-        Input,
-    },
+    input::{devices::tracked_device::TrackedDeviceType, Input},
     openxr_data::{Hand, RealOpenXrData, SessionData},
     tracy_span,
 };
@@ -12,7 +9,7 @@ use log::{debug, error, trace, warn};
 use openvr as vr;
 use openxr as xr;
 use std::ffi::CStr;
-use std::sync::{atomic::Ordering, Arc, Mutex};
+use std::sync::{Arc, Mutex};
 
 #[derive(Copy, Clone)]
 pub struct ViewData {
@@ -448,62 +445,18 @@ impl vr::IVRSystem022_Interface for System {
         size: u32,
         pose: *mut vr::TrackedDevicePose_t,
     ) -> bool {
-        if self.input.get().is_none() {
+        let Some(input) = self.input.get() else {
             return false;
-        }
+        };
 
-        let input = self.input.get().unwrap();
-        let devices = input.devices.read().unwrap();
-
-        for (i, device) in devices.iter().enumerate() {
-            let current = device.connected();
-
-            if device
-                .get_base_device()
-                .previous_connected
-                .compare_exchange(!current, current, Ordering::Relaxed, Ordering::Relaxed)
-                .is_ok()
-            {
-                debug!(
-                    "sending {:?} {}connected",
-                    device.get_type(),
-                    if current { "" } else { "not " }
-                );
-
-                // Since the VREvent_t struct can be a variable size, it seems a little dangerous to
-                // create a reference to it, so we'll just operate through pointers.
-                // The eventType, trackedDeviceIndex, and eventAgeSeconds fields have always existed.
-                unsafe {
-                    (&raw mut (*event).eventType).write(if current {
-                        vr::EVREventType::TrackedDeviceActivated as u32
-                    } else {
-                        vr::EVREventType::TrackedDeviceDeactivated as u32
-                    });
-
-                    (&raw mut (*event).trackedDeviceIndex).write(i as vr::TrackedDeviceIndex_t);
-                    (&raw mut (*event).eventAgeSeconds).write(0.0);
-                    if !pose.is_null() {
-                        pose.write(
-                            self.input
-                                .force(|_| Input::new(self.openxr.clone()))
-                                .get_device_pose(i as vr::TrackedDeviceIndex_t, Some(origin)),
-                        );
-                    }
-                }
-                return true;
-            }
-        }
-
-        self.input.get().is_some_and(|input| {
             let got_event = input.get_next_event(size, event);
             if got_event && !pose.is_null() {
                 unsafe {
                     let index = (&raw const (*event).trackedDeviceIndex).read();
-                    pose.write(input.get_device_pose(index, None));
+                    pose.write(input.get_device_pose(index, Some(origin)));
                 }
             }
             got_event
-        })
     }
 
     fn PollNextEvent(&self, event: *mut vr::VREvent_t, size: u32) -> bool {
@@ -716,51 +669,32 @@ impl vr::IVRSystem022_Interface for System {
     }
 
     fn IsTrackedDeviceConnected(&self, device_index: vr::TrackedDeviceIndex_t) -> bool {
-        self.input.get().map_or(false, |input| {
-            input
-                .devices
-                .read()
-                .unwrap()
-                .get_device(device_index)
-                .map_or(false, |device| device.connected())
-        })
+        self.input
+            .get()
+            .is_some_and(|input| input.is_device_connected(device_index))
     }
 
     fn GetTrackedDeviceClass(&self, index: vr::TrackedDeviceIndex_t) -> vr::ETrackedDeviceClass {
-        self.input
-            .get()
-            .map_or(vr::ETrackedDeviceClass::Invalid, |input| {
-                input
-                    .devices
-                    .read()
-                    .unwrap()
-                    .get_device(index)
-                    .map_or(vr::ETrackedDeviceClass::Invalid, |device| {
-                        device.get_type().into()
-                    })
-            })
+        TrackedDeviceType::try_from(index).map_or(vr::ETrackedDeviceClass::Invalid, |device| {
+            match device {
+                TrackedDeviceType::Hmd => vr::ETrackedDeviceClass::HMD,
+                TrackedDeviceType::Controller(_) => vr::ETrackedDeviceClass::Controller,
+            }
+        })
     }
+
     fn GetControllerRoleForTrackedDeviceIndex(
         &self,
         index: vr::TrackedDeviceIndex_t,
     ) -> vr::ETrackedControllerRole {
-        self.input
-            .get()
-            .and_then(|input| {
-                input
-                    .devices
-                    .read()
-                    .unwrap()
-                    .get_device(index)
-                    .and_then(|device| Some(device.get_type().into()))
-            })
-            .unwrap_or(vr::ETrackedControllerRole::Invalid)
+        Hand::try_from(index).map_or(vr::ETrackedControllerRole::Invalid, |hand| hand.into())
     }
+
     fn GetTrackedDeviceIndexForControllerRole(
         &self,
         role: vr::ETrackedControllerRole,
     ) -> vr::TrackedDeviceIndex_t {
-        TrackedDeviceType::from(role).into()
+        Hand::try_from(role).map_or(vr::k_unTrackedDeviceIndexInvalid, |hand| hand.into())
     }
     fn ApplyTransform(
         &self,
-- 
2.51.0


From 1d59cfdf5658a04685942eddee097fa5c170c085 Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Thu, 10 Apr 2025 18:43:12 +0200
Subject: [PATCH 10/25] initialize HMD as connected

---
 src/input/devices/tracked_device.rs | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/input/devices/tracked_device.rs b/src/input/devices/tracked_device.rs
index d8cbac0..6e0bb2d 100644
--- a/src/input/devices/tracked_device.rs
+++ b/src/input/devices/tracked_device.rs
@@ -61,8 +61,12 @@ impl XrTrackedDevice {
             device_type,
             interaction_profile: Mutex::new(None),
             profile_path: AtomicPath::new(),
-            connected: AtomicBool::new(false),
-            previous_connected: AtomicBool::new(false),
+            connected: if device_type == TrackedDeviceType::Hmd {
+                true.into()
+            } else {
+                false.into()
+            },
+            previous_connected: false.into(),
         }
     }
 
-- 
2.51.0


From 59c267f17168e0be4cc5ffb3d7ea7b078996f0fb Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Sat, 12 Apr 2025 19:43:18 +0200
Subject: [PATCH 11/25] devices: cleanup

---
 src/input.rs                         | 85 ++++++++++++----------------
 src/input/action_manifest.rs         | 16 +++---
 src/input/action_manifest/helpers.rs |  4 +-
 src/input/devices.rs                 | 17 +++---
 src/input/devices/controller.rs      | 46 ++++-----------
 src/input/devices/tracked_device.rs  | 20 +++++--
 src/input/legacy.rs                  | 19 +++----
 src/input/skeletal.rs                |  5 +-
 src/system.rs                        |  2 +-
 9 files changed, 89 insertions(+), 125 deletions(-)

diff --git a/src/input.rs b/src/input.rs
index 12233b0..ef6c61e 100644
--- a/src/input.rs
+++ b/src/input.rs
@@ -116,19 +116,16 @@ impl<C: openxr_data::Compositor> Input<C> {
             })
             .collect();
 
-        let left_hand = devices
-            .get_controller(Hand::Left)
-            .get_controller_variables()
-            .unwrap();
-        let right_hand = devices
-            .get_controller(Hand::Right)
-            .get_controller_variables()
-            .unwrap();
-
         let pose_data = PoseData::new(
             &openxr.instance,
-            left_hand.subaction_path,
-            right_hand.subaction_path,
+            devices
+                .get_controller(Hand::Left)
+                .get_controller_subaction_path()
+                .unwrap(),
+            devices
+                .get_controller(Hand::Right)
+                .get_controller_subaction_path()
+                .unwrap(),
         );
         openxr
             .session_data
@@ -166,16 +163,13 @@ impl<C: openxr_data::Compositor> Input<C> {
         } else {
             let devices = self.devices.read().ok()?;
 
-            let left_hand = devices
-                .get_controller(Hand::Left)
-                .get_controller_variables()?;
-            let right_hand = devices
-                .get_controller(Hand::Right)
-                .get_controller_variables()?;
-
             match InputSourceKey::from(KeyData::from_ffi(handle)) {
-                x if x == self.left_hand_key => Some(left_hand.subaction_path),
-                x if x == self.right_hand_key => Some(right_hand.subaction_path),
+                x if x == self.left_hand_key => devices
+                    .get_controller(Hand::Left)
+                    .get_controller_subaction_path(),
+                x if x == self.right_hand_key => devices
+                    .get_controller(Hand::Right)
+                    .get_controller_subaction_path(),
                 _ => None,
             }
         }
@@ -780,15 +774,10 @@ impl<C: openxr_data::Compositor> vr::IVRInput010_Interface for Input<C> {
         let (active_origin, hand) = match loaded.try_get_action(action) {
             Ok(ActionData::Pose) => {
                 let (mut hand, interaction_profile) = match subaction_path {
-                    x if x == left_hand.get_controller_variables().unwrap().subaction_path => {
+                    x if x == left_hand.get_controller_subaction_path().unwrap() => {
                         (Some(Hand::Left), Some(left_hand.profile_path.load()))
                     }
-                    x if x
-                        == right_hand
-                            .get_controller_variables()
-                            .unwrap()
-                            .subaction_path =>
-                    {
+                    x if x == right_hand.get_controller_subaction_path().unwrap() => {
                         (Some(Hand::Right), Some(right_hand.profile_path.load()))
                     }
                     x if x == xr::Path::NULL => (None, None),
@@ -1330,11 +1319,11 @@ impl<C: openxr_data::Compositor> Input<C> {
 
         for hand in [Hand::Left, Hand::Right] {
             let controller = devices.get_controller(hand);
-            let vars = controller.get_controller_variables().unwrap();
+            let subaction_path = controller.get_controller_subaction_path().unwrap();
 
             let profile_path = session
                 .session
-                .current_interaction_profile(vars.subaction_path)
+                .current_interaction_profile(subaction_path)
                 .unwrap();
 
             controller.profile_path.store(profile_path);
@@ -1361,7 +1350,7 @@ impl<C: openxr_data::Compositor> Input<C> {
 
             info!(
                 "{} interaction profile changed: {}",
-                HandPath::from(vars.hand),
+                HandPath::from(hand),
                 profile_name
             )
         }
@@ -1518,23 +1507,20 @@ impl<C: openxr_data::Compositor> Input<C> {
     pub fn post_session_restart(&self, data: &SessionData) {
         let devices = self.devices.read().unwrap();
 
-        let left_hand = devices
-            .get_controller(Hand::Left)
-            .get_controller_variables()
-            .unwrap();
-        let right_hand = devices
-            .get_controller(Hand::Right)
-            .get_controller_variables()
-            .unwrap();
-
         // This function is called while a write lock is called on the session, and as such should
         // not use self.openxr.session_data.get().
         data.input_data
             .pose_data
             .set(PoseData::new(
                 &self.openxr.instance,
-                left_hand.subaction_path,
-                right_hand.subaction_path,
+                devices
+                    .get_controller(Hand::Left)
+                    .get_controller_subaction_path()
+                    .unwrap(),
+                devices
+                    .get_controller(Hand::Right)
+                    .get_controller_subaction_path()
+                    .unwrap(),
             ))
             .unwrap_or_else(|_| panic!("PoseData already setup"));
         if let Some(path) = self.loaded_actions_path.get() {
@@ -1568,16 +1554,15 @@ impl<C: openxr_data::Compositor> Input<C> {
                 // VREvent_t can be different sizes depending on the OpenVR version,
                 // so we use raw pointers to avoid creating a reference, because if the
                 // size doesn't match our VREvent_t's size, we are in UB land
-                unsafe {
-                    (&raw mut (*out).eventType).write(if current {
-                        vr::EVREventType::TrackedDeviceActivated as u32
+                self.events.lock().unwrap().push_back(InputEvent {
+                    ty: if current {
+                        vr::EVREventType::TrackedDeviceActivated
                     } else {
-                        vr::EVREventType::TrackedDeviceDeactivated as u32
-                    });
-
-                    (&raw mut (*out).trackedDeviceIndex).write(i as vr::TrackedDeviceIndex_t);
-                    (&raw mut (*out).eventAgeSeconds).write(0.0);
-                }
+                        vr::EVREventType::TrackedDeviceDeactivated
+                    },
+                    index: i as vr::TrackedDeviceIndex_t,
+                    data: Default::default(),
+                });
                 return true;
             }
         }
diff --git a/src/input/action_manifest.rs b/src/input/action_manifest.rs
index 30d15ca..7f73751 100644
--- a/src/input/action_manifest.rs
+++ b/src/input/action_manifest.rs
@@ -100,13 +100,13 @@ impl<C: openxr_data::Compositor> Input<C> {
         debug!("Loaded {} action sets.", sets.len());
 
         let devices = self.devices.read().unwrap();
-        let left_hand = devices
+        let left_hand_subaction_path = devices
             .get_controller(Hand::Left)
-            .get_controller_variables()
+            .get_controller_subaction_path()
             .ok_or(vr::EVRInputError::InvalidDevice)?;
-        let right_hand = devices
+        let right_hand_subaction_path = devices
             .get_controller(Hand::Right)
-            .get_controller_variables()
+            .get_controller_subaction_path()
             .ok_or(vr::EVRInputError::InvalidDevice)?;
 
         let actions = load_actions(
@@ -115,8 +115,8 @@ impl<C: openxr_data::Compositor> Input<C> {
             english.as_ref(),
             &mut sets,
             manifest.actions,
-            left_hand.subaction_path,
-            right_hand.subaction_path,
+            left_hand_subaction_path,
+            right_hand_subaction_path,
         )?;
         debug!("Loaded {} actions.", actions.len());
 
@@ -126,8 +126,8 @@ impl<C: openxr_data::Compositor> Input<C> {
             .get_or_init(|| {
                 SkeletalInputActionData::new(
                     &self.openxr.instance,
-                    left_hand.subaction_path,
-                    right_hand.subaction_path,
+                    left_hand_subaction_path,
+                    right_hand_subaction_path,
                 )
             });
 
diff --git a/src/input/action_manifest/helpers.rs b/src/input/action_manifest/helpers.rs
index 6bd04f0..6fd0060 100644
--- a/src/input/action_manifest/helpers.rs
+++ b/src/input/action_manifest/helpers.rs
@@ -62,8 +62,8 @@ impl BindingsLoadContext<'_> {
         let right_hand = devices.get_controller(Hand::Right);
 
         let hands = [
-            left_hand.get_controller_variables()?.subaction_path,
-            right_hand.get_controller_variables()?.subaction_path,
+            left_hand.get_controller_subaction_path()?,
+            right_hand.get_controller_subaction_path()?,
         ];
 
         let bindings_parsed = self
diff --git a/src/input/devices.rs b/src/input/devices.rs
index c7556fb..b2824d6 100644
--- a/src/input/devices.rs
+++ b/src/input/devices.rs
@@ -1,4 +1,3 @@
-use controller::ControllerVariables;
 use tracked_device::{TrackedDeviceType, XrTrackedDevice};
 
 use openvr as vr;
@@ -20,14 +19,14 @@ impl TrackedDeviceList {
         Self {
             devices: vec![
                 XrTrackedDevice::new(TrackedDeviceType::Hmd),
-                XrTrackedDevice::new(TrackedDeviceType::Controller(ControllerVariables::new(
-                    xr_instance,
-                    Hand::Left,
-                ))),
-                XrTrackedDevice::new(TrackedDeviceType::Controller(ControllerVariables::new(
-                    xr_instance,
-                    Hand::Right,
-                ))),
+                XrTrackedDevice::new(TrackedDeviceType::Controller {
+                    hand: Hand::Left,
+                    subaction_path: xr_instance.string_to_path(Hand::Left.into()).unwrap(),
+                }),
+                XrTrackedDevice::new(TrackedDeviceType::Controller {
+                    hand: Hand::Right,
+                    subaction_path: xr_instance.string_to_path(Hand::Right.into()).unwrap(),
+                }),
             ],
         }
     }
diff --git a/src/input/devices/controller.rs b/src/input/devices/controller.rs
index 854a80e..725a32f 100644
--- a/src/input/devices/controller.rs
+++ b/src/input/devices/controller.rs
@@ -7,34 +7,6 @@ use super::tracked_device::{TrackedDeviceType, XrTrackedDevice};
 
 use log::trace;
 
-#[derive(Debug, Copy, Clone, PartialEq)]
-pub struct ControllerVariables {
-    pub hand: Hand,
-    pub subaction_path: xr::Path,
-}
-
-impl Default for ControllerVariables {
-    fn default() -> Self {
-        Self {
-            hand: Hand::Left,
-            subaction_path: xr::Path::default(),
-        }
-    }
-}
-
-impl ControllerVariables {
-    pub fn new(instance: &xr::Instance, hand: Hand) -> Self {
-
-        Self {
-            hand,
-            subaction_path: match hand {
-                Hand::Left => instance.string_to_path(hand.into()).unwrap(),
-                Hand::Right => instance.string_to_path(hand.into()).unwrap(),
-            },
-        }
-    }
-}
-
 impl XrTrackedDevice {
     pub fn get_controller_pose(
         &self,
@@ -43,7 +15,7 @@ impl XrTrackedDevice {
         origin: vr::ETrackingUniverseOrigin,
     ) -> Option<vr::TrackedDevicePose_t> {
         let pose_data = session_data.input_data.pose_data.get().unwrap();
-        let space = match self.get_controller_variables()?.hand {
+        let space = match self.get_controller_hand()? {
             Hand::Left => &pose_data.left_space,
             Hand::Right => &pose_data.right_space,
         };
@@ -66,11 +38,17 @@ impl XrTrackedDevice {
         Some(vr::space_relation_to_openvr_pose(location, velocity))
     }
 
-    pub fn get_controller_variables(&self) -> Option<ControllerVariables> {
-        if let TrackedDeviceType::Controller(vars) = self.device_type {
-            Some(vars)
-        } else {
-            None
+    pub fn get_controller_subaction_path(&self) -> Option<xr::Path> {
+        match self.device_type {
+            TrackedDeviceType::Controller { subaction_path, .. } => Some(subaction_path),
+            _ => None,
+        }
+    }
+
+    pub fn get_controller_hand(&self) -> Option<Hand> {
+        match self.device_type {
+            TrackedDeviceType::Controller { hand, .. } => Some(hand),
+            _ => None,
         }
     }
 }
diff --git a/src/input/devices/tracked_device.rs b/src/input/devices/tracked_device.rs
index 6e0bb2d..1bf2455 100644
--- a/src/input/devices/tracked_device.rs
+++ b/src/input/devices/tracked_device.rs
@@ -7,26 +7,28 @@ use std::{
 };
 
 use openvr as vr;
+use openxr as xr;
 
 use crate::{
     input::InteractionProfile,
     openxr_data::{AtomicPath, Hand, OpenXrData, SessionData},
 };
 
-use super::controller::ControllerVariables;
-
 #[derive(Debug, Copy, Clone, PartialEq)]
 #[allow(dead_code)]
 pub enum TrackedDeviceType {
     Hmd,
-    Controller(ControllerVariables),
+    Controller {
+        hand: Hand,
+        subaction_path: xr::Path,
+    },
 }
 
 impl fmt::Display for TrackedDeviceType {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         match self {
             Self::Hmd => write!(f, "HMD"),
-            Self::Controller(vars) => match vars.hand {
+            Self::Controller { hand, .. } => match hand {
                 Hand::Left => write!(f, "Left Hand"),
                 Hand::Right => write!(f, "Right Hand"),
             },
@@ -40,8 +42,14 @@ impl TryFrom<vr::TrackedDeviceIndex_t> for TrackedDeviceType {
     fn try_from(value: vr::TrackedDeviceIndex_t) -> Result<Self, Self::Error> {
         match value {
             0 => Ok(Self::Hmd),
-            1 => Ok(Self::Controller(ControllerVariables::default())),
-            2 => Ok(Self::Controller(ControllerVariables::default())),
+            1 => Ok(Self::Controller {
+                hand: Hand::Left,
+                subaction_path: xr::Path::default(),
+            }),
+            2 => Ok(Self::Controller {
+                hand: Hand::Right,
+                subaction_path: xr::Path::default(),
+            }),
             _ => Err(()),
         }
     }
diff --git a/src/input/legacy.rs b/src/input/legacy.rs
index 3f8976c..40ab5b9 100644
--- a/src/input/legacy.rs
+++ b/src/input/legacy.rs
@@ -47,11 +47,8 @@ impl<C: openxr_data::Compositor> Input<C> {
 
         let legacy = LegacyActionData::new(
             &self.openxr.instance,
-            left_hand.get_controller_variables().unwrap().subaction_path,
-            right_hand
-                .get_controller_variables()
-                .unwrap()
-                .subaction_path,
+            left_hand.get_controller_subaction_path().unwrap(),
+            right_hand.get_controller_subaction_path().unwrap(),
         );
         let input_data = &session_data.input_data;
 
@@ -111,10 +108,10 @@ impl<C: openxr_data::Compositor> Input<C> {
             return;
         };
         let devices = self.devices.read().unwrap();
-        let controller = devices.get_controller(hand.into());
-        let hand_path = controller.get_controller_variables()
-            .unwrap()
-            .subaction_path;
+        let hand_path = devices
+            .get_controller(hand)
+            .get_controller_subaction_path()
+            .unwrap();
 
         let Some(legacy) = data.input_data.get_legacy_actions() else {
             debug!("tried triggering haptic, but legacy actions aren't ready");
@@ -181,13 +178,11 @@ impl<C: openxr_data::Compositor> Input<C> {
 
         let devices = self.devices.read().unwrap();
 
-        let Some(controller) = devices.get_controller(hand).get_controller_variables() else {
+        let Some(hand_path) = devices.get_controller(hand).get_controller_subaction_path() else {
             debug!("tried getting controller state, but no controller variables were found");
             return false;
         };
 
-        let hand_path = controller.subaction_path;
-
         let data = self.openxr.session_data.get();
 
         state.unPacketNum = self.legacy_state.packet_num.load(Ordering::Relaxed);
diff --git a/src/input/skeletal.rs b/src/input/skeletal.rs
index a72ef0b..1ddcf59 100644
--- a/src/input/skeletal.rs
+++ b/src/input/skeletal.rs
@@ -353,9 +353,8 @@ impl<C: openxr_data::Compositor> Input<C> {
 
         let subaction = devices
             .get_controller(hand)
-            .get_controller_variables()
-            .unwrap()
-            .subaction_path;
+            .get_controller_subaction_path()
+            .unwrap();
 
         let thumb_touch = actions
             .thumb_touch
diff --git a/src/system.rs b/src/system.rs
index 439ab49..abb7942 100644
--- a/src/system.rs
+++ b/src/system.rs
@@ -678,7 +678,7 @@ impl vr::IVRSystem022_Interface for System {
         TrackedDeviceType::try_from(index).map_or(vr::ETrackedDeviceClass::Invalid, |device| {
             match device {
                 TrackedDeviceType::Hmd => vr::ETrackedDeviceClass::HMD,
-                TrackedDeviceType::Controller(_) => vr::ETrackedDeviceClass::Controller,
+                TrackedDeviceType::Controller { .. } => vr::ETrackedDeviceClass::Controller,
             }
         })
     }
-- 
2.51.0


From 5da6227702ecff70f60116a7143611320a6cbd87 Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Sat, 12 Apr 2025 20:30:11 +0200
Subject: [PATCH 12/25] unpublicize XrTrackedDevice members

---
 src/input.rs                        | 23 +++++++-----------
 src/input/devices.rs                |  4 ----
 src/input/devices/controller.rs     |  4 ++--
 src/input/devices/tracked_device.rs | 37 ++++++++++++++++++++++-------
 4 files changed, 39 insertions(+), 29 deletions(-)

diff --git a/src/input.rs b/src/input.rs
index ef6c61e..0c97361 100644
--- a/src/input.rs
+++ b/src/input.rs
@@ -775,10 +775,10 @@ impl<C: openxr_data::Compositor> vr::IVRInput010_Interface for Input<C> {
             Ok(ActionData::Pose) => {
                 let (mut hand, interaction_profile) = match subaction_path {
                     x if x == left_hand.get_controller_subaction_path().unwrap() => {
-                        (Some(Hand::Left), Some(left_hand.profile_path.load()))
+                        (Some(Hand::Left), Some(left_hand.get_profile_path()))
                     }
                     x if x == right_hand.get_controller_subaction_path().unwrap() => {
-                        (Some(Hand::Right), Some(right_hand.profile_path.load()))
+                        (Some(Hand::Right), Some(right_hand.get_profile_path()))
                     }
                     x if x == xr::Path::NULL => (None, None),
                     _ => unreachable!(),
@@ -786,8 +786,8 @@ impl<C: openxr_data::Compositor> vr::IVRInput010_Interface for Input<C> {
 
                 let get_first_bound_hand_profile = || {
                     loaded
-                        .try_get_pose(action, left_hand.profile_path.load())
-                        .or_else(|_| loaded.try_get_pose(action, right_hand.profile_path.load()))
+                        .try_get_pose(action, left_hand.get_profile_path())
+                        .or_else(|_| loaded.try_get_pose(action, right_hand.get_profile_path()))
                         .ok()
                 };
 
@@ -1072,8 +1072,8 @@ impl<C: openxr_data::Compositor> vr::IVRInput010_Interface for Input<C> {
         let left_hand = devices.get_controller(Hand::Left.into());
         let right_hand = devices.get_controller(Hand::Right.into());
 
-        let left_profile = left_hand.profile_path.load();
-        let right_profile = right_hand.profile_path.load();
+        let left_profile = left_hand.get_profile_path();
+        let right_profile = right_hand.get_profile_path();
         for key in &actions.actions_with_custom_bindings {
             let unsync_custom_bindings = |key, profile| {
                 if profile == xr::Path::NULL {
@@ -1326,7 +1326,7 @@ impl<C: openxr_data::Compositor> Input<C> {
                 .current_interaction_profile(subaction_path)
                 .unwrap();
 
-            controller.profile_path.store(profile_path);
+            controller.set_profile_path(profile_path);
 
             let profile_name = match profile_path {
                 xr::Path::NULL => {
@@ -1426,8 +1426,7 @@ impl<C: openxr_data::Compositor> Input<C> {
             .read()
             .ok()?
             .get_device(hand.into())?
-            .profile_path
-            .load();
+            .get_profile_path();
 
         self.profile_map.get(&path).map(|v| &**v)
     }
@@ -1540,11 +1539,7 @@ impl<C: openxr_data::Compositor> Input<C> {
         for (i, device) in devices.iter().enumerate() {
             let current = device.connected();
 
-            if device
-                .previous_connected
-                .compare_exchange(!current, current, Ordering::Relaxed, Ordering::Relaxed)
-                .is_ok()
-            {
+            if device.compare_exchange_connected().is_ok() {
                 debug!(
                     "sending {:?} {}connected",
                     device.get_type(),
diff --git a/src/input/devices.rs b/src/input/devices.rs
index b2824d6..b8a9c39 100644
--- a/src/input/devices.rs
+++ b/src/input/devices.rs
@@ -70,8 +70,4 @@ impl TrackedDeviceList {
     pub fn iter(&self) -> std::slice::Iter<'_, XrTrackedDevice> {
         self.devices.iter()
     }
-
-    pub fn len(&self) -> usize {
-        self.devices.len()
-    }
 }
diff --git a/src/input/devices/controller.rs b/src/input/devices/controller.rs
index 725a32f..d238ea1 100644
--- a/src/input/devices/controller.rs
+++ b/src/input/devices/controller.rs
@@ -39,14 +39,14 @@ impl XrTrackedDevice {
     }
 
     pub fn get_controller_subaction_path(&self) -> Option<xr::Path> {
-        match self.device_type {
+        match self.get_type() {
             TrackedDeviceType::Controller { subaction_path, .. } => Some(subaction_path),
             _ => None,
         }
     }
 
     pub fn get_controller_hand(&self) -> Option<Hand> {
-        match self.device_type {
+        match self.get_type() {
             TrackedDeviceType::Controller { hand, .. } => Some(hand),
             _ => None,
         }
diff --git a/src/input/devices/tracked_device.rs b/src/input/devices/tracked_device.rs
index 1bf2455..625e70b 100644
--- a/src/input/devices/tracked_device.rs
+++ b/src/input/devices/tracked_device.rs
@@ -56,11 +56,11 @@ impl TryFrom<vr::TrackedDeviceIndex_t> for TrackedDeviceType {
 }
 
 pub struct XrTrackedDevice {
-    pub device_type: TrackedDeviceType,
-    pub interaction_profile: Mutex<Option<&'static dyn InteractionProfile>>,
-    pub profile_path: AtomicPath,
-    pub connected: AtomicBool,
-    pub previous_connected: AtomicBool,
+    device_type: TrackedDeviceType,
+    interaction_profile: Mutex<Option<&'static dyn InteractionProfile>>,
+    profile_path: AtomicPath,
+    connected: AtomicBool,
+    previous_connected: AtomicBool,
 }
 
 impl XrTrackedDevice {
@@ -100,10 +100,6 @@ impl XrTrackedDevice {
         self.connected.store(connected, Ordering::Relaxed);
     }
 
-    pub fn get_type(&self) -> TrackedDeviceType {
-        self.device_type
-    }
-
     pub fn set_interaction_profile(&self, profile: &'static dyn InteractionProfile) {
         self.interaction_profile.lock().unwrap().replace(profile);
     }
@@ -111,4 +107,27 @@ impl XrTrackedDevice {
     pub fn get_interaction_profile(&self) -> Option<&'static dyn InteractionProfile> {
         self.interaction_profile.lock().unwrap().as_ref().copied()
     }
+
+    pub fn get_profile_path(&self) -> xr::Path {
+        self.profile_path.load()
+    }
+
+    pub fn set_profile_path(&self, path: xr::Path) {
+        self.profile_path.store(path);
+    }
+
+    pub fn compare_exchange_connected(&self) -> Result<bool, bool> {
+        let current = self.connected();
+
+        self.previous_connected.compare_exchange(
+            !current,
+            current,
+            Ordering::Relaxed,
+            Ordering::Relaxed,
+        )
+    }
+
+    pub fn get_type(&self) -> TrackedDeviceType {
+        self.device_type
+    }
 }
-- 
2.51.0


From 9698c401b9d91f46d930bd5470c1af9269b39b4e Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Sat, 12 Apr 2025 20:31:49 +0200
Subject: [PATCH 13/25] tracked_device: remove left over #[allow(dead_code)]

---
 src/input/devices/tracked_device.rs | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/input/devices/tracked_device.rs b/src/input/devices/tracked_device.rs
index 625e70b..bee618e 100644
--- a/src/input/devices/tracked_device.rs
+++ b/src/input/devices/tracked_device.rs
@@ -15,7 +15,6 @@ use crate::{
 };
 
 #[derive(Debug, Copy, Clone, PartialEq)]
-#[allow(dead_code)]
 pub enum TrackedDeviceType {
     Hmd,
     Controller {
-- 
2.51.0


From 7d94ea2873ec1a0875aa0ae06d8f32bb6d6996dc Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Sat, 12 Apr 2025 20:33:45 +0200
Subject: [PATCH 14/25] restrict device specific functions to (super)

---
 src/input/devices/controller.rs | 2 +-
 src/input/devices/hmd.rs        | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/input/devices/controller.rs b/src/input/devices/controller.rs
index d238ea1..39264d5 100644
--- a/src/input/devices/controller.rs
+++ b/src/input/devices/controller.rs
@@ -8,7 +8,7 @@ use super::tracked_device::{TrackedDeviceType, XrTrackedDevice};
 use log::trace;
 
 impl XrTrackedDevice {
-    pub fn get_controller_pose(
+    pub(super) fn get_controller_pose(
         &self,
         xr_data: &OpenXrData<impl crate::openxr_data::Compositor>,
         session_data: &SessionData,
diff --git a/src/input/devices/hmd.rs b/src/input/devices/hmd.rs
index a50ec20..8abc16e 100644
--- a/src/input/devices/hmd.rs
+++ b/src/input/devices/hmd.rs
@@ -5,7 +5,7 @@ use crate::openxr_data::{OpenXrData, SessionData};
 use super::tracked_device::XrTrackedDevice;
 
 impl XrTrackedDevice {
-    pub fn get_hmd_pose(
+    pub(super) fn get_hmd_pose(
         &self,
         xr_data: &OpenXrData<impl crate::openxr_data::Compositor>,
         session_data: &SessionData,
-- 
2.51.0


From 9ba8e4cfd1db6405dd4d2a41c23358401c91b231 Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Sat, 12 Apr 2025 20:35:10 +0200
Subject: [PATCH 15/25] tracked:device: remove unneeded Display impl

---
 src/input/devices/tracked_device.rs | 21 +++------------------
 1 file changed, 3 insertions(+), 18 deletions(-)

diff --git a/src/input/devices/tracked_device.rs b/src/input/devices/tracked_device.rs
index bee618e..86a1428 100644
--- a/src/input/devices/tracked_device.rs
+++ b/src/input/devices/tracked_device.rs
@@ -1,9 +1,6 @@
-use std::{
-    fmt,
-    sync::{
-        atomic::{AtomicBool, Ordering},
-        Mutex,
-    },
+use std::sync::{
+    atomic::{AtomicBool, Ordering},
+    Mutex,
 };
 
 use openvr as vr;
@@ -23,18 +20,6 @@ pub enum TrackedDeviceType {
     },
 }
 
-impl fmt::Display for TrackedDeviceType {
-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-        match self {
-            Self::Hmd => write!(f, "HMD"),
-            Self::Controller { hand, .. } => match hand {
-                Hand::Left => write!(f, "Left Hand"),
-                Hand::Right => write!(f, "Right Hand"),
-            },
-        }
-    }
-}
-
 impl TryFrom<vr::TrackedDeviceIndex_t> for TrackedDeviceType {
     type Error = ();
 
-- 
2.51.0


From 6d9506a07f2f8a8059fd74eeaee896f619b503e8 Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Thu, 17 Apr 2025 18:39:32 +0200
Subject: [PATCH 16/25] devices: cleanup

---
 src/input/devices.rs | 25 -------------------------
 1 file changed, 25 deletions(-)

diff --git a/src/input/devices.rs b/src/input/devices.rs
index b8a9c39..c02e4a8 100644
--- a/src/input/devices.rs
+++ b/src/input/devices.rs
@@ -13,7 +13,6 @@ pub struct TrackedDeviceList {
     devices: Vec<XrTrackedDevice>,
 }
 
-#[allow(dead_code)]
 impl TrackedDeviceList {
     pub fn new(xr_instance: &xr::Instance) -> Self {
         Self {
@@ -35,30 +34,6 @@ impl TrackedDeviceList {
         self.devices.get(device_index as usize)
     }
 
-    pub fn get_device_mut(
-        &mut self,
-        device_index: vr::TrackedDeviceIndex_t,
-    ) -> Option<&mut XrTrackedDevice> {
-        self.devices.get_mut(device_index as usize)
-    }
-
-    /// This function is only intended to be used for the HMD and controllers. For other devices, it'll return the first match.
-    pub fn get_device_by_type(&self, device_type: TrackedDeviceType) -> Option<&XrTrackedDevice> {
-        self.devices
-            .iter()
-            .find(|device| device.get_type() == device_type)
-    }
-
-    /// This function is only intended to be used for the HMD and controllers. For other devices, it'll return the first match.
-    pub fn get_device_by_type_mut(
-        &mut self,
-        device_type: TrackedDeviceType,
-    ) -> Option<&mut XrTrackedDevice> {
-        self.devices
-            .iter_mut()
-            .find(|device| device.get_type() == device_type)
-    }
-
     pub fn get_hmd(&self) -> &XrTrackedDevice {
         unsafe { self.devices.get_unchecked(0) }
     }
-- 
2.51.0


From 7c080b8a7c065be6d091d2f89cdc8747fb09416f Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Tue, 22 Apr 2025 17:11:20 +0200
Subject: [PATCH 17/25] store subaction paths in input

---
 src/input.rs                         | 54 +++++++++++++---------------
 src/input/action_manifest.rs         | 20 +++--------
 src/input/action_manifest/helpers.rs | 12 +++----
 src/input/devices.rs                 | 13 ++-----
 src/input/devices/controller.rs      |  7 ----
 src/input/devices/tracked_device.rs  | 15 ++------
 src/input/legacy.rs                  | 21 +++--------
 src/input/skeletal.rs                |  7 +---
 src/system.rs                        | 14 ++++----
 9 files changed, 51 insertions(+), 112 deletions(-)

diff --git a/src/input.rs b/src/input.rs
index 0c97361..b84ccfd 100644
--- a/src/input.rs
+++ b/src/input.rs
@@ -58,6 +58,7 @@ pub struct Input<C: openxr_data::Compositor> {
     skeletal_tracking_level: RwLock<vr::EVRSkeletalTrackingLevel>,
     profile_map: HashMap<xr::Path, &'static profiles::ProfileProperties>,
     estimated_finger_state: [Mutex<FingerState>; 2],
+    subaction_paths: [Mutex<xr::Path>; 2],
     events: Mutex<VecDeque<InputEvent>>,
     loading_actions: AtomicBool,
     devices: RwLock<TrackedDeviceList>,
@@ -99,7 +100,7 @@ impl<T> Drop for WriteOnDrop<T> {
 
 impl<C: openxr_data::Compositor> Input<C> {
     pub fn new(openxr: Arc<OpenXrData<C>>) -> Self {
-        let devices = TrackedDeviceList::new(&openxr.instance);
+        let devices = TrackedDeviceList::new();
         let mut map = SlotMap::with_key();
         let left_hand_key = map.insert(c"/user/hand/left".into());
         let right_hand_key = map.insert(c"/user/hand/right".into());
@@ -116,16 +117,15 @@ impl<C: openxr_data::Compositor> Input<C> {
             })
             .collect();
 
+        let subaction_paths = [
+            Mutex::new(openxr.instance.string_to_path("/user/hand/left").unwrap()),
+            Mutex::new(openxr.instance.string_to_path("/user/hand/right").unwrap()),
+        ];
+
         let pose_data = PoseData::new(
             &openxr.instance,
-            devices
-                .get_controller(Hand::Left)
-                .get_controller_subaction_path()
-                .unwrap(),
-            devices
-                .get_controller(Hand::Right)
-                .get_controller_subaction_path()
-                .unwrap(),
+            subaction_paths[0].lock().unwrap().clone(),
+            subaction_paths[1].lock().unwrap().clone(),
         );
         openxr
             .session_data
@@ -152,24 +152,26 @@ impl<C: openxr_data::Compositor> Input<C> {
                 Mutex::new(FingerState::new()),
                 Mutex::new(FingerState::new()),
             ],
+            subaction_paths,
             events: Mutex::default(),
             loading_actions: false.into(),
         }
     }
 
+    pub fn get_subaction_path(&self, hand: Hand) -> xr::Path {
+        match hand {
+            Hand::Left => self.subaction_paths[0].lock().unwrap().clone(),
+            Hand::Right => self.subaction_paths[1].lock().unwrap().clone(),
+        }
+    }
+
     fn subaction_path_from_handle(&self, handle: vr::VRInputValueHandle_t) -> Option<xr::Path> {
         if handle == vr::k_ulInvalidInputValueHandle {
             Some(xr::Path::NULL)
         } else {
-            let devices = self.devices.read().ok()?;
-
             match InputSourceKey::from(KeyData::from_ffi(handle)) {
-                x if x == self.left_hand_key => devices
-                    .get_controller(Hand::Left)
-                    .get_controller_subaction_path(),
-                x if x == self.right_hand_key => devices
-                    .get_controller(Hand::Right)
-                    .get_controller_subaction_path(),
+                x if x == self.left_hand_key => Some(self.get_subaction_path(Hand::Left)),
+                x if x == self.right_hand_key => Some(self.get_subaction_path(Hand::Right)),
                 _ => None,
             }
         }
@@ -774,10 +776,10 @@ impl<C: openxr_data::Compositor> vr::IVRInput010_Interface for Input<C> {
         let (active_origin, hand) = match loaded.try_get_action(action) {
             Ok(ActionData::Pose) => {
                 let (mut hand, interaction_profile) = match subaction_path {
-                    x if x == left_hand.get_controller_subaction_path().unwrap() => {
+                    x if x == self.get_subaction_path(Hand::Left) => {
                         (Some(Hand::Left), Some(left_hand.get_profile_path()))
                     }
-                    x if x == right_hand.get_controller_subaction_path().unwrap() => {
+                    x if x == self.get_subaction_path(Hand::Right) => {
                         (Some(Hand::Right), Some(right_hand.get_profile_path()))
                     }
                     x if x == xr::Path::NULL => (None, None),
@@ -1319,7 +1321,7 @@ impl<C: openxr_data::Compositor> Input<C> {
 
         for hand in [Hand::Left, Hand::Right] {
             let controller = devices.get_controller(hand);
-            let subaction_path = controller.get_controller_subaction_path().unwrap();
+            let subaction_path = self.get_subaction_path(hand);
 
             let profile_path = session
                 .session
@@ -1504,22 +1506,14 @@ impl<C: openxr_data::Compositor> Input<C> {
     }
 
     pub fn post_session_restart(&self, data: &SessionData) {
-        let devices = self.devices.read().unwrap();
-
         // This function is called while a write lock is called on the session, and as such should
         // not use self.openxr.session_data.get().
         data.input_data
             .pose_data
             .set(PoseData::new(
                 &self.openxr.instance,
-                devices
-                    .get_controller(Hand::Left)
-                    .get_controller_subaction_path()
-                    .unwrap(),
-                devices
-                    .get_controller(Hand::Right)
-                    .get_controller_subaction_path()
-                    .unwrap(),
+                self.get_subaction_path(Hand::Left),
+                self.get_subaction_path(Hand::Right),
             ))
             .unwrap_or_else(|_| panic!("PoseData already setup"));
         if let Some(path) = self.loaded_actions_path.get() {
diff --git a/src/input/action_manifest.rs b/src/input/action_manifest.rs
index 7f73751..ceee15a 100644
--- a/src/input/action_manifest.rs
+++ b/src/input/action_manifest.rs
@@ -99,15 +99,8 @@ impl<C: openxr_data::Compositor> Input<C> {
         )?;
         debug!("Loaded {} action sets.", sets.len());
 
-        let devices = self.devices.read().unwrap();
-        let left_hand_subaction_path = devices
-            .get_controller(Hand::Left)
-            .get_controller_subaction_path()
-            .ok_or(vr::EVRInputError::InvalidDevice)?;
-        let right_hand_subaction_path = devices
-            .get_controller(Hand::Right)
-            .get_controller_subaction_path()
-            .ok_or(vr::EVRInputError::InvalidDevice)?;
+        let left_hand_subaction_path = self.get_subaction_path(Hand::Left);
+        let right_hand_subaction_path = self.get_subaction_path(Hand::Right);
 
         let actions = load_actions(
             &self.openxr.instance,
@@ -874,12 +867,9 @@ impl<C: openxr_data::Compositor> Input<C> {
                     let bindings = LazyCell::new(load_bindings);
                     for profile in profiles {
                         if let Some(bindings) = bindings.as_ref() {
-                            if let Some(mut context) = context.for_profile(
-                                &self.openxr,
-                                &self.devices.read().unwrap(),
-                                profile,
-                                other,
-                            ) {
+                            if let Some(mut context) =
+                                context.for_profile(self, &self.openxr, profile, other)
+                            {
                                 self.load_bindings_for_profile(bindings, &mut context);
                             }
                         }
diff --git a/src/input/action_manifest/helpers.rs b/src/input/action_manifest/helpers.rs
index 6fd0060..11c6d83 100644
--- a/src/input/action_manifest/helpers.rs
+++ b/src/input/action_manifest/helpers.rs
@@ -2,10 +2,9 @@ use crate::input::action_manifest::{ActionPath, ControllerType, LoadedActionData
 use crate::input::custom_bindings::{
     AsActionData, AsIter, BindingData, CustomBindingHelper, Names,
 };
-use crate::input::devices::TrackedDeviceList;
 use crate::input::skeletal::SkeletalInputActionData;
 use crate::input::ActionData::{Bool, Vector1, Vector2};
-use crate::input::{ActionData, BoundPose, ExtraActionData, InteractionProfile};
+use crate::input::{ActionData, BoundPose, ExtraActionData, Input, InteractionProfile};
 use crate::openxr_data::OpenXrData;
 use crate::openxr_data::{self, Hand};
 use log::{trace, warn};
@@ -47,8 +46,8 @@ impl<'a> BindingsLoadContext<'a> {
 impl BindingsLoadContext<'_> {
     pub fn for_profile<'a, 'b: 'a, C: openxr_data::Compositor>(
         &'b mut self,
+        input: &'a Input<C>,
         openxr: &'a OpenXrData<C>,
-        devices: &'a TrackedDeviceList,
         profile: &'a dyn InteractionProfile,
         controller_type: &'a ControllerType,
     ) -> Option<BindingsProfileLoadContext<'a>> {
@@ -58,12 +57,9 @@ impl BindingsLoadContext<'_> {
             return None;
         };
 
-        let left_hand = devices.get_controller(Hand::Left);
-        let right_hand = devices.get_controller(Hand::Right);
-
         let hands = [
-            left_hand.get_controller_subaction_path()?,
-            right_hand.get_controller_subaction_path()?,
+            input.get_subaction_path(Hand::Left),
+            input.get_subaction_path(Hand::Right),
         ];
 
         let bindings_parsed = self
diff --git a/src/input/devices.rs b/src/input/devices.rs
index c02e4a8..04068c6 100644
--- a/src/input/devices.rs
+++ b/src/input/devices.rs
@@ -1,7 +1,6 @@
 use tracked_device::{TrackedDeviceType, XrTrackedDevice};
 
 use openvr as vr;
-use openxr as xr;
 
 use crate::openxr_data::Hand;
 
@@ -14,18 +13,12 @@ pub struct TrackedDeviceList {
 }
 
 impl TrackedDeviceList {
-    pub fn new(xr_instance: &xr::Instance) -> Self {
+    pub fn new() -> Self {
         Self {
             devices: vec![
                 XrTrackedDevice::new(TrackedDeviceType::Hmd),
-                XrTrackedDevice::new(TrackedDeviceType::Controller {
-                    hand: Hand::Left,
-                    subaction_path: xr_instance.string_to_path(Hand::Left.into()).unwrap(),
-                }),
-                XrTrackedDevice::new(TrackedDeviceType::Controller {
-                    hand: Hand::Right,
-                    subaction_path: xr_instance.string_to_path(Hand::Right.into()).unwrap(),
-                }),
+                XrTrackedDevice::new(TrackedDeviceType::Controller { hand: Hand::Left }),
+                XrTrackedDevice::new(TrackedDeviceType::Controller { hand: Hand::Right }),
             ],
         }
     }
diff --git a/src/input/devices/controller.rs b/src/input/devices/controller.rs
index 39264d5..ae3eadb 100644
--- a/src/input/devices/controller.rs
+++ b/src/input/devices/controller.rs
@@ -38,13 +38,6 @@ impl XrTrackedDevice {
         Some(vr::space_relation_to_openvr_pose(location, velocity))
     }
 
-    pub fn get_controller_subaction_path(&self) -> Option<xr::Path> {
-        match self.get_type() {
-            TrackedDeviceType::Controller { subaction_path, .. } => Some(subaction_path),
-            _ => None,
-        }
-    }
-
     pub fn get_controller_hand(&self) -> Option<Hand> {
         match self.get_type() {
             TrackedDeviceType::Controller { hand, .. } => Some(hand),
diff --git a/src/input/devices/tracked_device.rs b/src/input/devices/tracked_device.rs
index 86a1428..8f18f12 100644
--- a/src/input/devices/tracked_device.rs
+++ b/src/input/devices/tracked_device.rs
@@ -14,10 +14,7 @@ use crate::{
 #[derive(Debug, Copy, Clone, PartialEq)]
 pub enum TrackedDeviceType {
     Hmd,
-    Controller {
-        hand: Hand,
-        subaction_path: xr::Path,
-    },
+    Controller { hand: Hand },
 }
 
 impl TryFrom<vr::TrackedDeviceIndex_t> for TrackedDeviceType {
@@ -26,14 +23,8 @@ impl TryFrom<vr::TrackedDeviceIndex_t> for TrackedDeviceType {
     fn try_from(value: vr::TrackedDeviceIndex_t) -> Result<Self, Self::Error> {
         match value {
             0 => Ok(Self::Hmd),
-            1 => Ok(Self::Controller {
-                hand: Hand::Left,
-                subaction_path: xr::Path::default(),
-            }),
-            2 => Ok(Self::Controller {
-                hand: Hand::Right,
-                subaction_path: xr::Path::default(),
-            }),
+            1 => Ok(Self::Controller { hand: Hand::Left }),
+            2 => Ok(Self::Controller { hand: Hand::Right }),
             _ => Err(()),
         }
     }
diff --git a/src/input/legacy.rs b/src/input/legacy.rs
index 40ab5b9..5be5167 100644
--- a/src/input/legacy.rs
+++ b/src/input/legacy.rs
@@ -41,14 +41,10 @@ impl<C: openxr_data::Compositor> Input<C> {
         let session_data = self.openxr.session_data.get();
         let session = &session_data.session;
 
-        let devices = self.devices.read().unwrap();
-        let left_hand = devices.get_controller(Hand::Left.into());
-        let right_hand = devices.get_controller(Hand::Right.into());
-
         let legacy = LegacyActionData::new(
             &self.openxr.instance,
-            left_hand.get_controller_subaction_path().unwrap(),
-            right_hand.get_controller_subaction_path().unwrap(),
+            self.get_subaction_path(Hand::Left),
+            self.get_subaction_path(Hand::Right),
         );
         let input_data = &session_data.input_data;
 
@@ -107,11 +103,7 @@ impl<C: openxr_data::Compositor> Input<C> {
             debug!("tried triggering haptic on invalid device index: {device_index}");
             return;
         };
-        let devices = self.devices.read().unwrap();
-        let hand_path = devices
-            .get_controller(hand)
-            .get_controller_subaction_path()
-            .unwrap();
+        let hand_path = self.get_subaction_path(hand);
 
         let Some(legacy) = data.input_data.get_legacy_actions() else {
             debug!("tried triggering haptic, but legacy actions aren't ready");
@@ -176,12 +168,7 @@ impl<C: openxr_data::Compositor> Input<C> {
             return false;
         };
 
-        let devices = self.devices.read().unwrap();
-
-        let Some(hand_path) = devices.get_controller(hand).get_controller_subaction_path() else {
-            debug!("tried getting controller state, but no controller variables were found");
-            return false;
-        };
+        let hand_path = self.get_subaction_path(hand);
 
         let data = self.openxr.session_data.get();
 
diff --git a/src/input/skeletal.rs b/src/input/skeletal.rs
index 1ddcf59..e7bf352 100644
--- a/src/input/skeletal.rs
+++ b/src/input/skeletal.rs
@@ -349,12 +349,7 @@ impl<C: openxr_data::Compositor> Input<C> {
             .unwrap()
             .actions;
 
-        let devices = self.devices.read().unwrap();
-
-        let subaction = devices
-            .get_controller(hand)
-            .get_controller_subaction_path()
-            .unwrap();
+        let subaction = self.get_subaction_path(hand);
 
         let thumb_touch = actions
             .thumb_touch
diff --git a/src/system.rs b/src/system.rs
index abb7942..027d70a 100644
--- a/src/system.rs
+++ b/src/system.rs
@@ -449,14 +449,14 @@ impl vr::IVRSystem022_Interface for System {
             return false;
         };
 
-            let got_event = input.get_next_event(size, event);
-            if got_event && !pose.is_null() {
-                unsafe {
-                    let index = (&raw const (*event).trackedDeviceIndex).read();
-                    pose.write(input.get_device_pose(index, Some(origin)));
-                }
+        let got_event = input.get_next_event(size, event);
+        if got_event && !pose.is_null() {
+            unsafe {
+                let index = (&raw const (*event).trackedDeviceIndex).read();
+                pose.write(input.get_device_pose(index, Some(origin)));
             }
-            got_event
+        }
+        got_event
     }
 
     fn PollNextEvent(&self, event: *mut vr::VREvent_t, size: u32) -> bool {
-- 
2.51.0


From 435ff5f84cbae02c660021973b88a0e723a0f4d1 Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Tue, 22 Apr 2025 17:29:49 +0200
Subject: [PATCH 18/25] cache device poses

---
 src/input.rs                        |  8 ++++++--
 src/input/devices/tracked_device.rs | 17 +++++++++++++++--
 2 files changed, 21 insertions(+), 4 deletions(-)

diff --git a/src/input.rs b/src/input.rs
index b84ccfd..77f6296 100644
--- a/src/input.rs
+++ b/src/input.rs
@@ -1362,9 +1362,13 @@ impl<C: openxr_data::Compositor> Input<C> {
         tracy_span!();
         let data = self.openxr.session_data.get();
         let input_data = &data.input_data;
-        if let Some(loaded) = input_data.get_loaded_actions() {
-            let devices = self.devices.read().unwrap();
+        let devices = self.devices.read().unwrap();
 
+        devices.iter().for_each(|device| {
+            device.clear_pose_cache();
+        });
+
+        if let Some(loaded) = input_data.get_loaded_actions() {
             let left_hand = devices.get_controller(Hand::Left);
             let right_hand = devices.get_controller(Hand::Right);
 
diff --git a/src/input/devices/tracked_device.rs b/src/input/devices/tracked_device.rs
index 8f18f12..bf821da 100644
--- a/src/input/devices/tracked_device.rs
+++ b/src/input/devices/tracked_device.rs
@@ -36,6 +36,7 @@ pub struct XrTrackedDevice {
     profile_path: AtomicPath,
     connected: AtomicBool,
     previous_connected: AtomicBool,
+    pose_cache: Mutex<Option<vr::TrackedDevicePose_t>>,
 }
 
 impl XrTrackedDevice {
@@ -50,6 +51,7 @@ impl XrTrackedDevice {
                 false.into()
             },
             previous_connected: false.into(),
+            pose_cache: Mutex::new(None),
         }
     }
 
@@ -59,12 +61,19 @@ impl XrTrackedDevice {
         session_data: &SessionData,
         origin: vr::ETrackingUniverseOrigin,
     ) -> Option<vr::TrackedDevicePose_t> {
-        match self.device_type {
+        let mut pose_cache = self.pose_cache.lock().ok()?;
+        if let Some(pose) = *pose_cache {
+            return Some(pose);
+        }
+
+        *pose_cache = match self.device_type {
             TrackedDeviceType::Hmd => self.get_hmd_pose(xr_data, session_data, origin),
             TrackedDeviceType::Controller { .. } => {
                 self.get_controller_pose(xr_data, session_data, origin)
             }
-        }
+        };
+
+        *pose_cache
     }
 
     pub fn connected(&self) -> bool {
@@ -91,6 +100,10 @@ impl XrTrackedDevice {
         self.profile_path.store(path);
     }
 
+    pub fn clear_pose_cache(&self) {
+        std::mem::take(&mut *self.pose_cache.lock().unwrap());
+    }
+
     pub fn compare_exchange_connected(&self) -> Result<bool, bool> {
         let current = self.connected();
 
-- 
2.51.0


From 78ad9ed1fb7f79f5be1fd8383598cbc8effc14c1 Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Thu, 24 Apr 2025 16:51:34 +0200
Subject: [PATCH 19/25] store subaction paths in a struct instead of a slice

---
 src/input.rs         | 17 +++++++----------
 src/input/devices.rs | 19 +++++++++++++++++++
 2 files changed, 26 insertions(+), 10 deletions(-)

diff --git a/src/input.rs b/src/input.rs
index 77f6296..ef7ace7 100644
--- a/src/input.rs
+++ b/src/input.rs
@@ -9,6 +9,7 @@ pub mod devices;
 #[cfg(test)]
 mod tests;
 
+use devices::SubactionPaths;
 use devices::TrackedDeviceList;
 use profiles::MainAxisType;
 pub use profiles::{InteractionProfile, Profiles};
@@ -58,7 +59,7 @@ pub struct Input<C: openxr_data::Compositor> {
     skeletal_tracking_level: RwLock<vr::EVRSkeletalTrackingLevel>,
     profile_map: HashMap<xr::Path, &'static profiles::ProfileProperties>,
     estimated_finger_state: [Mutex<FingerState>; 2],
-    subaction_paths: [Mutex<xr::Path>; 2],
+    subaction_paths: SubactionPaths,
     events: Mutex<VecDeque<InputEvent>>,
     loading_actions: AtomicBool,
     devices: RwLock<TrackedDeviceList>,
@@ -104,6 +105,7 @@ impl<C: openxr_data::Compositor> Input<C> {
         let mut map = SlotMap::with_key();
         let left_hand_key = map.insert(c"/user/hand/left".into());
         let right_hand_key = map.insert(c"/user/hand/right".into());
+        let subaction_paths = SubactionPaths::new(&openxr.instance);
         let profile_map = Profiles::get()
             .profiles_iter()
             .map(|profile| {
@@ -117,15 +119,10 @@ impl<C: openxr_data::Compositor> Input<C> {
             })
             .collect();
 
-        let subaction_paths = [
-            Mutex::new(openxr.instance.string_to_path("/user/hand/left").unwrap()),
-            Mutex::new(openxr.instance.string_to_path("/user/hand/right").unwrap()),
-        ];
-
         let pose_data = PoseData::new(
             &openxr.instance,
-            subaction_paths[0].lock().unwrap().clone(),
-            subaction_paths[1].lock().unwrap().clone(),
+            subaction_paths.left,
+            subaction_paths.right,
         );
         openxr
             .session_data
@@ -160,8 +157,8 @@ impl<C: openxr_data::Compositor> Input<C> {
 
     pub fn get_subaction_path(&self, hand: Hand) -> xr::Path {
         match hand {
-            Hand::Left => self.subaction_paths[0].lock().unwrap().clone(),
-            Hand::Right => self.subaction_paths[1].lock().unwrap().clone(),
+            Hand::Left => self.subaction_paths.left,
+            Hand::Right => self.subaction_paths.right,
         }
     }
 
diff --git a/src/input/devices.rs b/src/input/devices.rs
index 04068c6..72e019f 100644
--- a/src/input/devices.rs
+++ b/src/input/devices.rs
@@ -1,6 +1,7 @@
 use tracked_device::{TrackedDeviceType, XrTrackedDevice};
 
 use openvr as vr;
+use openxr as xr;
 
 use crate::openxr_data::Hand;
 
@@ -12,6 +13,24 @@ pub struct TrackedDeviceList {
     devices: Vec<XrTrackedDevice>,
 }
 
+pub struct SubactionPaths {
+    pub left: xr::Path,
+    pub right: xr::Path,
+}
+
+impl SubactionPaths {
+    pub fn new(instance: &xr::Instance) -> Self {
+        let left = instance
+            .string_to_path("/user/hand/left")
+            .expect("Failed to convert string to path");
+        let right = instance
+            .string_to_path("/user/hand/right")
+            .expect("Failed to convert string to path");
+
+        Self { left, right }
+    }
+}
+
 impl TrackedDeviceList {
     pub fn new() -> Self {
         Self {
-- 
2.51.0


From 4d0ec73c2a7e70ce920ca6bae2b2a90745b0f1bb Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Thu, 24 Apr 2025 17:00:27 +0200
Subject: [PATCH 20/25] cleanup

---
 src/input.rs                        |   2 +-
 src/input/devices.rs                | 176 +++++++++++++++++++++++++++-
 src/input/devices/hmd.rs            |  26 ----
 src/input/devices/tracked_device.rs | 121 -------------------
 src/system.rs                       |   2 +-
 5 files changed, 173 insertions(+), 154 deletions(-)
 delete mode 100644 src/input/devices/hmd.rs
 delete mode 100644 src/input/devices/tracked_device.rs

diff --git a/src/input.rs b/src/input.rs
index ef7ace7..4d2ed84 100644
--- a/src/input.rs
+++ b/src/input.rs
@@ -155,7 +155,7 @@ impl<C: openxr_data::Compositor> Input<C> {
         }
     }
 
-    pub fn get_subaction_path(&self, hand: Hand) -> xr::Path {
+    fn get_subaction_path(&self, hand: Hand) -> xr::Path {
         match hand {
             Hand::Left => self.subaction_paths.left,
             Hand::Right => self.subaction_paths.right,
diff --git a/src/input/devices.rs b/src/input/devices.rs
index 72e019f..bb352df 100644
--- a/src/input/devices.rs
+++ b/src/input/devices.rs
@@ -1,13 +1,179 @@
-use tracked_device::{TrackedDeviceType, XrTrackedDevice};
+use std::sync::{atomic::{AtomicBool, Ordering}, Mutex};
 
 use openvr as vr;
 use openxr as xr;
 
-use crate::openxr_data::Hand;
+use crate::openxr_data::{AtomicPath, Hand, OpenXrData, SessionData};
+use log::trace;
 
-mod controller;
-mod hmd;
-pub mod tracked_device;
+use super::InteractionProfile;
+
+#[derive(Debug, Copy, Clone, PartialEq)]
+pub enum TrackedDeviceType {
+    Hmd,
+    Controller { hand: Hand },
+}
+
+impl TryFrom<vr::TrackedDeviceIndex_t> for TrackedDeviceType {
+    type Error = ();
+
+    fn try_from(value: vr::TrackedDeviceIndex_t) -> Result<Self, Self::Error> {
+        match value {
+            0 => Ok(Self::Hmd),
+            1 => Ok(Self::Controller { hand: Hand::Left }),
+            2 => Ok(Self::Controller { hand: Hand::Right }),
+            _ => Err(()),
+        }
+    }
+}
+
+pub struct XrTrackedDevice {
+    device_type: TrackedDeviceType,
+    interaction_profile: Mutex<Option<&'static dyn InteractionProfile>>,
+    profile_path: AtomicPath,
+    connected: AtomicBool,
+    previous_connected: AtomicBool,
+    pose_cache: Mutex<Option<vr::TrackedDevicePose_t>>,
+}
+
+impl XrTrackedDevice {
+    pub fn new(device_type: TrackedDeviceType) -> Self {
+        Self {
+            device_type,
+            interaction_profile: Mutex::new(None),
+            profile_path: AtomicPath::new(),
+            connected: if device_type == TrackedDeviceType::Hmd {
+                true.into()
+            } else {
+                false.into()
+            },
+            previous_connected: false.into(),
+            pose_cache: Mutex::new(None),
+        }
+    }
+
+    pub fn get_pose(
+        &self,
+        xr_data: &OpenXrData<impl crate::openxr_data::Compositor>,
+        session_data: &SessionData,
+        origin: vr::ETrackingUniverseOrigin,
+    ) -> Option<vr::TrackedDevicePose_t> {
+        let mut pose_cache = self.pose_cache.lock().ok()?;
+        if let Some(pose) = *pose_cache {
+            return Some(pose);
+        }
+
+        *pose_cache = match self.device_type {
+            TrackedDeviceType::Hmd => self.get_hmd_pose(xr_data, session_data, origin),
+            TrackedDeviceType::Controller { .. } => {
+                self.get_controller_pose(xr_data, session_data, origin)
+            }
+        };
+
+        *pose_cache
+    }
+
+    pub fn connected(&self) -> bool {
+        self.connected.load(Ordering::Relaxed)
+    }
+
+    pub fn set_connected(&self, connected: bool) {
+        self.connected.store(connected, Ordering::Relaxed);
+    }
+
+    pub fn set_interaction_profile(&self, profile: &'static dyn InteractionProfile) {
+        self.interaction_profile.lock().unwrap().replace(profile);
+    }
+
+    pub fn get_interaction_profile(&self) -> Option<&'static dyn InteractionProfile> {
+        self.interaction_profile.lock().unwrap().as_ref().copied()
+    }
+
+    pub fn get_profile_path(&self) -> xr::Path {
+        self.profile_path.load()
+    }
+
+    pub fn set_profile_path(&self, path: xr::Path) {
+        self.profile_path.store(path);
+    }
+
+    pub fn clear_pose_cache(&self) {
+        std::mem::take(&mut *self.pose_cache.lock().unwrap());
+    }
+
+    pub fn compare_exchange_connected(&self) -> Result<bool, bool> {
+        let current = self.connected();
+
+        self.previous_connected.compare_exchange(
+            !current,
+            current,
+            Ordering::Relaxed,
+            Ordering::Relaxed,
+        )
+    }
+
+    pub fn get_type(&self) -> TrackedDeviceType {
+        self.device_type
+    }
+
+    // Controllers
+    fn get_controller_pose(
+        &self,
+        xr_data: &OpenXrData<impl crate::openxr_data::Compositor>,
+        session_data: &SessionData,
+        origin: vr::ETrackingUniverseOrigin,
+    ) -> Option<vr::TrackedDevicePose_t> {
+        let pose_data = session_data.input_data.pose_data.get().unwrap();
+        let space = match self.get_controller_hand()? {
+            Hand::Left => &pose_data.left_space,
+            Hand::Right => &pose_data.right_space,
+        };
+
+        let (location, velocity) = if let Some(raw) = space.try_get_or_init_raw(
+            &self.get_interaction_profile(),
+            session_data,
+            &pose_data,
+        ) {
+            raw.relate(
+                session_data.get_space_for_origin(origin),
+                xr_data.display_time.get(),
+            )
+            .ok()?
+        } else {
+            trace!("Failed to get raw space, returning empty pose");
+            (xr::SpaceLocation::default(), xr::SpaceVelocity::default())
+        };
+
+        Some(vr::space_relation_to_openvr_pose(location, velocity))
+    }
+
+    pub fn get_controller_hand(&self) -> Option<Hand> {
+        match self.get_type() {
+            TrackedDeviceType::Controller { hand, .. } => Some(hand),
+            _ => None,
+        }
+    }
+
+    // HMD
+    fn get_hmd_pose(
+        &self,
+        xr_data: &OpenXrData<impl crate::openxr_data::Compositor>,
+        session_data: &SessionData,
+        origin: vr::ETrackingUniverseOrigin,
+    ) -> Option<vr::TrackedDevicePose_t> {
+        let (location, velocity) = {
+            session_data
+                .view_space
+                .relate(
+                    session_data.get_space_for_origin(origin),
+                    xr_data.display_time.get(),
+                )
+                .ok()?
+        };
+
+        Some(vr::space_relation_to_openvr_pose(location, velocity))
+    }
+}
 
 pub struct TrackedDeviceList {
     devices: Vec<XrTrackedDevice>,
diff --git a/src/input/devices/hmd.rs b/src/input/devices/hmd.rs
deleted file mode 100644
index 8abc16e..0000000
--- a/src/input/devices/hmd.rs
+++ /dev/null
@@ -1,26 +0,0 @@
-use openvr as vr;
-
-use crate::openxr_data::{OpenXrData, SessionData};
-
-use super::tracked_device::XrTrackedDevice;
-
-impl XrTrackedDevice {
-    pub(super) fn get_hmd_pose(
-        &self,
-        xr_data: &OpenXrData<impl crate::openxr_data::Compositor>,
-        session_data: &SessionData,
-        origin: vr::ETrackingUniverseOrigin,
-    ) -> Option<vr::TrackedDevicePose_t> {
-        let (location, velocity) = {
-            session_data
-                .view_space
-                .relate(
-                    session_data.get_space_for_origin(origin),
-                    xr_data.display_time.get(),
-                )
-                .ok()?
-        };
-
-        Some(vr::space_relation_to_openvr_pose(location, velocity))
-    }
-}
diff --git a/src/input/devices/tracked_device.rs b/src/input/devices/tracked_device.rs
deleted file mode 100644
index bf821da..0000000
--- a/src/input/devices/tracked_device.rs
+++ /dev/null
@@ -1,121 +0,0 @@
-use std::sync::{
-    atomic::{AtomicBool, Ordering},
-    Mutex,
-};
-
-use openvr as vr;
-use openxr as xr;
-
-use crate::{
-    input::InteractionProfile,
-    openxr_data::{AtomicPath, Hand, OpenXrData, SessionData},
-};
-
-#[derive(Debug, Copy, Clone, PartialEq)]
-pub enum TrackedDeviceType {
-    Hmd,
-    Controller { hand: Hand },
-}
-
-impl TryFrom<vr::TrackedDeviceIndex_t> for TrackedDeviceType {
-    type Error = ();
-
-    fn try_from(value: vr::TrackedDeviceIndex_t) -> Result<Self, Self::Error> {
-        match value {
-            0 => Ok(Self::Hmd),
-            1 => Ok(Self::Controller { hand: Hand::Left }),
-            2 => Ok(Self::Controller { hand: Hand::Right }),
-            _ => Err(()),
-        }
-    }
-}
-
-pub struct XrTrackedDevice {
-    device_type: TrackedDeviceType,
-    interaction_profile: Mutex<Option<&'static dyn InteractionProfile>>,
-    profile_path: AtomicPath,
-    connected: AtomicBool,
-    previous_connected: AtomicBool,
-    pose_cache: Mutex<Option<vr::TrackedDevicePose_t>>,
-}
-
-impl XrTrackedDevice {
-    pub fn new(device_type: TrackedDeviceType) -> Self {
-        Self {
-            device_type,
-            interaction_profile: Mutex::new(None),
-            profile_path: AtomicPath::new(),
-            connected: if device_type == TrackedDeviceType::Hmd {
-                true.into()
-            } else {
-                false.into()
-            },
-            previous_connected: false.into(),
-            pose_cache: Mutex::new(None),
-        }
-    }
-
-    pub fn get_pose(
-        &self,
-        xr_data: &OpenXrData<impl crate::openxr_data::Compositor>,
-        session_data: &SessionData,
-        origin: vr::ETrackingUniverseOrigin,
-    ) -> Option<vr::TrackedDevicePose_t> {
-        let mut pose_cache = self.pose_cache.lock().ok()?;
-        if let Some(pose) = *pose_cache {
-            return Some(pose);
-        }
-
-        *pose_cache = match self.device_type {
-            TrackedDeviceType::Hmd => self.get_hmd_pose(xr_data, session_data, origin),
-            TrackedDeviceType::Controller { .. } => {
-                self.get_controller_pose(xr_data, session_data, origin)
-            }
-        };
-
-        *pose_cache
-    }
-
-    pub fn connected(&self) -> bool {
-        self.connected.load(Ordering::Relaxed)
-    }
-
-    pub fn set_connected(&self, connected: bool) {
-        self.connected.store(connected, Ordering::Relaxed);
-    }
-
-    pub fn set_interaction_profile(&self, profile: &'static dyn InteractionProfile) {
-        self.interaction_profile.lock().unwrap().replace(profile);
-    }
-
-    pub fn get_interaction_profile(&self) -> Option<&'static dyn InteractionProfile> {
-        self.interaction_profile.lock().unwrap().as_ref().copied()
-    }
-
-    pub fn get_profile_path(&self) -> xr::Path {
-        self.profile_path.load()
-    }
-
-    pub fn set_profile_path(&self, path: xr::Path) {
-        self.profile_path.store(path);
-    }
-
-    pub fn clear_pose_cache(&self) {
-        std::mem::take(&mut *self.pose_cache.lock().unwrap());
-    }
-
-    pub fn compare_exchange_connected(&self) -> Result<bool, bool> {
-        let current = self.connected();
-
-        self.previous_connected.compare_exchange(
-            !current,
-            current,
-            Ordering::Relaxed,
-            Ordering::Relaxed,
-        )
-    }
-
-    pub fn get_type(&self) -> TrackedDeviceType {
-        self.device_type
-    }
-}
diff --git a/src/system.rs b/src/system.rs
index 027d70a..ca4d01f 100644
--- a/src/system.rs
+++ b/src/system.rs
@@ -1,6 +1,6 @@
 use crate::{
     clientcore::{Injected, Injector},
-    input::{devices::tracked_device::TrackedDeviceType, Input},
+    input::{devices::TrackedDeviceType, Input},
     openxr_data::{Hand, RealOpenXrData, SessionData},
     tracy_span,
 };
-- 
2.51.0


From 694e097c405706088e5e4c1acdc9fa45e4e547ba Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Thu, 24 Apr 2025 17:08:55 +0200
Subject: [PATCH 21/25] move some device related function to devices

---
 src/input.rs         | 148 ----------------------------------------
 src/input/devices.rs | 159 ++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 156 insertions(+), 151 deletions(-)

diff --git a/src/input.rs b/src/input.rs
index 4d2ed84..569af79 100644
--- a/src/input.rs
+++ b/src/input.rs
@@ -11,7 +11,6 @@ mod tests;
 
 use devices::SubactionPaths;
 use devices::TrackedDeviceList;
-use profiles::MainAxisType;
 pub use profiles::{InteractionProfile, Profiles};
 use skeletal::FingerState;
 use skeletal::SkeletalInputActionData;
@@ -1247,70 +1246,6 @@ impl<C: openxr_data::Compositor> vr::IVRInput005On006 for Input<C> {
 }
 
 impl<C: openxr_data::Compositor> Input<C> {
-    pub fn get_poses(
-        &self,
-        poses: &mut [vr::TrackedDevicePose_t],
-        origin: Option<vr::ETrackingUniverseOrigin>,
-    ) {
-        tracy_span!();
-        let devices = self.devices.read().unwrap();
-        let session_data = self.openxr.session_data.get();
-
-        poses.iter_mut().enumerate().for_each(|(i, pose)| {
-            let device = devices.get_device(i as u32);
-
-            if let Some(device) = device {
-                *pose = device
-                    .get_pose(
-                        &self.openxr,
-                        &session_data,
-                        origin.unwrap_or(session_data.current_origin),
-                    )
-                    .unwrap_or_default();
-            }
-        });
-    }
-
-    pub fn get_controller_pose(
-        &self,
-        hand: Hand,
-        origin: Option<vr::ETrackingUniverseOrigin>,
-    ) -> vr::TrackedDevicePose_t {
-        self.get_device_pose(hand.into(), origin)
-    }
-
-    pub fn get_device_pose(
-        &self,
-        index: vr::TrackedDeviceIndex_t,
-        origin: Option<vr::ETrackingUniverseOrigin>,
-    ) -> vr::TrackedDevicePose_t {
-        tracy_span!();
-
-        let session_data = self.openxr.session_data.get();
-
-        if let Some(device) = self.devices.read().unwrap().get_device(index) {
-            device.get_pose(
-                &self.openxr,
-                &session_data,
-                origin.unwrap_or(session_data.current_origin),
-            ).unwrap_or_default()
-        } else {
-            Default::default()
-        }
-    }
-
-    pub fn is_device_connected(&self, index: vr::TrackedDeviceIndex_t) -> bool {
-        let Some(devices) = self.devices.read().ok() else {
-            return false;
-        };
-
-        let Some(device) = devices.get_device(index) else {
-            return false;
-        };
-
-        device.connected()
-    }
-
     pub fn interaction_profile_changed(&self) {
         let session = self.openxr.session_data.get();
         let devices = self.devices.read().unwrap();
@@ -1423,89 +1358,6 @@ impl<C: openxr_data::Compositor> Input<C> {
         }
     }
 
-    fn get_profile_data(&self, hand: Hand) -> Option<&profiles::ProfileProperties> {
-        let path = self
-            .devices
-            .read()
-            .ok()?
-            .get_device(hand.into())?
-            .get_profile_path();
-
-        self.profile_map.get(&path).map(|v| &**v)
-    }
-
-    pub fn get_controller_string_tracked_property(
-        &self,
-        hand: Hand,
-        property: vr::ETrackedDeviceProperty,
-    ) -> Option<&'static CStr> {
-        self.get_profile_data(hand).and_then(|data| {
-            match property {
-                // Audica likes to apply controller specific tweaks via this property
-                vr::ETrackedDeviceProperty::ControllerType_String => {
-                    Some(data.openvr_controller_type)
-                }
-                // I Expect You To Die 3 identifies controllers with this property -
-                // why it couldn't just use ControllerType instead is beyond me...
-                // Because some controllers have different model names for each hand......
-                vr::ETrackedDeviceProperty::ModelNumber_String => Some(*data.model.get(hand)),
-                // Resonite won't recognize controllers without this
-                vr::ETrackedDeviceProperty::RenderModelName_String => {
-                    Some(*data.render_model_name.get(hand))
-                }
-                vr::ETrackedDeviceProperty::RegisteredDeviceType_String => {
-                    Some(*data.registered_device_type.get(hand))
-                }
-                vr::ETrackedDeviceProperty::TrackingSystemName_String => {
-                    Some(data.tracking_system_name)
-                }
-                // Required for controllers to be acknowledged in I Expect You To Die 3
-                vr::ETrackedDeviceProperty::SerialNumber_String => {
-                    Some(*data.serial_number.get(hand))
-                }
-                vr::ETrackedDeviceProperty::ManufacturerName_String => Some(data.manufacturer_name),
-                _ => None,
-            }
-        })
-    }
-
-    pub fn get_controller_int_tracked_property(
-        &self,
-        hand: Hand,
-        property: vr::ETrackedDeviceProperty,
-    ) -> Option<i32> {
-        self.get_profile_data(hand).and_then(|data| match property {
-            vr::ETrackedDeviceProperty::Axis0Type_Int32 => match data.main_axis {
-                MainAxisType::Thumbstick => Some(vr::EVRControllerAxisType::Joystick as _),
-                MainAxisType::Trackpad => Some(vr::EVRControllerAxisType::TrackPad as _),
-            },
-            vr::ETrackedDeviceProperty::Axis1Type_Int32 => {
-                Some(vr::EVRControllerAxisType::Trigger as _)
-            }
-            vr::ETrackedDeviceProperty::Axis2Type_Int32 => {
-                // This is actually the grip, and gets recognized as such
-                Some(vr::EVRControllerAxisType::Trigger as _)
-            }
-            // TODO: report knuckles trackpad?
-            vr::ETrackedDeviceProperty::Axis3Type_Int32
-            | vr::ETrackedDeviceProperty::Axis4Type_Int32 => {
-                Some(vr::EVRControllerAxisType::None as _)
-            }
-            _ => None,
-        })
-    }
-
-    pub fn get_controller_uint_tracked_property(
-        &self,
-        hand: Hand,
-        property: vr::ETrackedDeviceProperty,
-    ) -> Option<u64> {
-        self.get_profile_data(hand).and_then(|data| match property {
-            vr::ETrackedDeviceProperty::SupportedButtons_Uint64 => Some(data.legacy_buttons_mask),
-            _ => None,
-        })
-    }
-
     pub fn post_session_restart(&self, data: &SessionData) {
         // This function is called while a write lock is called on the session, and as such should
         // not use self.openxr.session_data.get().
diff --git a/src/input/devices.rs b/src/input/devices.rs
index bb352df..577f582 100644
--- a/src/input/devices.rs
+++ b/src/input/devices.rs
@@ -1,12 +1,16 @@
-use std::sync::{atomic::{AtomicBool, Ordering}, Mutex};
+use std::{ffi::CStr, sync::{
+    atomic::{AtomicBool, Ordering},
+    Mutex,
+}};
 
 use openvr as vr;
 use openxr as xr;
 
-use crate::openxr_data::{AtomicPath, Hand, OpenXrData, SessionData};
+use crate::openxr_data::{self, AtomicPath, Hand, OpenXrData, SessionData};
+use crate::tracy_span;
 use log::trace;
 
-use super::InteractionProfile;
+use super::{profiles::MainAxisType, Input, InteractionProfile};
 
 #[derive(Debug, Copy, Clone, PartialEq)]
 pub enum TrackedDeviceType {
@@ -224,3 +228,152 @@ impl TrackedDeviceList {
         self.devices.iter()
     }
 }
+
+impl<C: openxr_data::Compositor> Input<C> {
+    pub fn get_poses(
+        &self,
+        poses: &mut [vr::TrackedDevicePose_t],
+        origin: Option<vr::ETrackingUniverseOrigin>,
+    ) {
+        tracy_span!();
+        let devices = self.devices.read().unwrap();
+        let session_data = self.openxr.session_data.get();
+
+        poses.iter_mut().enumerate().for_each(|(i, pose)| {
+            let device = devices.get_device(i as u32);
+
+            if let Some(device) = device {
+                *pose = device
+                    .get_pose(
+                        &self.openxr,
+                        &session_data,
+                        origin.unwrap_or(session_data.current_origin),
+                    )
+                    .unwrap_or_default();
+            }
+        });
+    }
+
+    pub fn get_controller_pose(
+        &self,
+        hand: Hand,
+        origin: Option<vr::ETrackingUniverseOrigin>,
+    ) -> vr::TrackedDevicePose_t {
+        self.get_device_pose(hand.into(), origin)
+    }
+
+    pub fn get_device_pose(
+        &self,
+        index: vr::TrackedDeviceIndex_t,
+        origin: Option<vr::ETrackingUniverseOrigin>,
+    ) -> vr::TrackedDevicePose_t {
+        tracy_span!();
+
+        let session_data = self.openxr.session_data.get();
+
+        if let Some(device) = self.devices.read().unwrap().get_device(index) {
+            device.get_pose(
+                &self.openxr,
+                &session_data,
+                origin.unwrap_or(session_data.current_origin),
+            ).unwrap_or_default()
+        } else {
+            Default::default()
+        }
+    }
+
+    pub fn is_device_connected(&self, index: vr::TrackedDeviceIndex_t) -> bool {
+        let Some(devices) = self.devices.read().ok() else {
+            return false;
+        };
+
+        let Some(device) = devices.get_device(index) else {
+            return false;
+        };
+
+        device.connected()
+    }
+
+    fn get_profile_data(&self, hand: Hand) -> Option<&super::profiles::ProfileProperties> {
+        let path = self
+            .devices
+            .read()
+            .ok()?
+            .get_device(hand.into())?
+            .get_profile_path();
+
+        self.profile_map.get(&path).map(|v| &**v)
+    }
+
+    pub fn get_controller_string_tracked_property(
+        &self,
+        hand: Hand,
+        property: vr::ETrackedDeviceProperty,
+    ) -> Option<&'static CStr> {
+        self.get_profile_data(hand).and_then(|data| {
+            match property {
+                // Audica likes to apply controller specific tweaks via this property
+                vr::ETrackedDeviceProperty::ControllerType_String => {
+                    Some(data.openvr_controller_type)
+                }
+                // I Expect You To Die 3 identifies controllers with this property -
+                // why it couldn't just use ControllerType instead is beyond me...
+                // Because some controllers have different model names for each hand......
+                vr::ETrackedDeviceProperty::ModelNumber_String => Some(*data.model.get(hand)),
+                // Resonite won't recognize controllers without this
+                vr::ETrackedDeviceProperty::RenderModelName_String => {
+                    Some(*data.render_model_name.get(hand))
+                }
+                vr::ETrackedDeviceProperty::RegisteredDeviceType_String => {
+                    Some(*data.registered_device_type.get(hand))
+                }
+                vr::ETrackedDeviceProperty::TrackingSystemName_String => {
+                    Some(data.tracking_system_name)
+                }
+                // Required for controllers to be acknowledged in I Expect You To Die 3
+                vr::ETrackedDeviceProperty::SerialNumber_String => {
+                    Some(*data.serial_number.get(hand))
+                }
+                vr::ETrackedDeviceProperty::ManufacturerName_String => Some(data.manufacturer_name),
+                _ => None,
+            }
+        })
+    }
+
+    pub fn get_controller_int_tracked_property(
+        &self,
+        hand: Hand,
+        property: vr::ETrackedDeviceProperty,
+    ) -> Option<i32> {
+        self.get_profile_data(hand).and_then(|data| match property {
+            vr::ETrackedDeviceProperty::Axis0Type_Int32 => match data.main_axis {
+                MainAxisType::Thumbstick => Some(vr::EVRControllerAxisType::Joystick as _),
+                MainAxisType::Trackpad => Some(vr::EVRControllerAxisType::TrackPad as _),
+            },
+            vr::ETrackedDeviceProperty::Axis1Type_Int32 => {
+                Some(vr::EVRControllerAxisType::Trigger as _)
+            }
+            vr::ETrackedDeviceProperty::Axis2Type_Int32 => {
+                // This is actually the grip, and gets recognized as such
+                Some(vr::EVRControllerAxisType::Trigger as _)
+            }
+            // TODO: report knuckles trackpad?
+            vr::ETrackedDeviceProperty::Axis3Type_Int32
+            | vr::ETrackedDeviceProperty::Axis4Type_Int32 => {
+                Some(vr::EVRControllerAxisType::None as _)
+            }
+            _ => None,
+        })
+    }
+
+    pub fn get_controller_uint_tracked_property(
+        &self,
+        hand: Hand,
+        property: vr::ETrackedDeviceProperty,
+    ) -> Option<u64> {
+        self.get_profile_data(hand).and_then(|data| match property {
+            vr::ETrackedDeviceProperty::SupportedButtons_Uint64 => Some(data.legacy_buttons_mask),
+            _ => None,
+        })
+    }
+}
-- 
2.51.0


From 37fe9a94db51024b4b393fa299dcf52954f81842 Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Thu, 24 Apr 2025 23:55:41 +0200
Subject: [PATCH 22/25] expect device activated events in legacy tests

---
 src/input.rs        | 1 -
 src/input/legacy.rs | 7 +++++--
 2 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/src/input.rs b/src/input.rs
index 569af79..2af9b1e 100644
--- a/src/input.rs
+++ b/src/input.rs
@@ -1405,7 +1405,6 @@ impl<C: openxr_data::Compositor> Input<C> {
                     index: i as vr::TrackedDeviceIndex_t,
                     data: Default::default(),
                 });
-                return true;
             }
         }
 
diff --git a/src/input/legacy.rs b/src/input/legacy.rs
index 5be5167..ab1d5f2 100644
--- a/src/input/legacy.rs
+++ b/src/input/legacy.rs
@@ -498,7 +498,7 @@ mod tests {
                 event.is_none(),
                 "Got unexpected event: {} ({msg})",
                 event.unwrap().ty
-            );
+            );  
         };
 
         let update_action_state = |left_state, right_state| {
@@ -551,7 +551,10 @@ mod tests {
         };
 
         let hands = [LeftHand, RightHand];
-        // Initial state
+        
+        while let Some(event) = get_event() {
+            assert_eq!(event.ty, vr::EVREventType::TrackedDeviceActivated as u32);
+        }
 
         for hand in hands {
             let state = get_state(hand);
-- 
2.51.0


From 75a96e1e1c25cde981a6ed2f3f9bd4325ce6c84e Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Fri, 25 Apr 2025 00:22:44 +0200
Subject: [PATCH 23/25] only create controllers if the interaction profile
 exists

---
 src/input.rs          |  88 +++++++++++++++++++++-----
 src/input/devices.rs  | 139 +++++++++++++++++++++++++++++-------------
 src/input/legacy.rs   |  10 +--
 src/input/skeletal.rs |  10 ++-
 src/input/tests.rs    |  23 ++++---
 src/openxr_data.rs    |  18 ------
 src/system.rs         |  94 +++++++++++++++++++++++-----
 7 files changed, 277 insertions(+), 105 deletions(-)

diff --git a/src/input.rs b/src/input.rs
index 2af9b1e..8fbe930 100644
--- a/src/input.rs
+++ b/src/input.rs
@@ -10,7 +10,10 @@ pub mod devices;
 mod tests;
 
 use devices::SubactionPaths;
+use devices::TrackedDeviceCreateInfo;
 use devices::TrackedDeviceList;
+use devices::TrackedDeviceType;
+use devices::XrTrackedDevice;
 pub use profiles::{InteractionProfile, Profiles};
 use skeletal::FingerState;
 use skeletal::SkeletalInputActionData;
@@ -773,20 +776,35 @@ impl<C: openxr_data::Compositor> vr::IVRInput010_Interface for Input<C> {
             Ok(ActionData::Pose) => {
                 let (mut hand, interaction_profile) = match subaction_path {
                     x if x == self.get_subaction_path(Hand::Left) => {
-                        (Some(Hand::Left), Some(left_hand.get_profile_path()))
+                        if let Some(left_hand) = left_hand {
+                            (Some(Hand::Left), Some(left_hand.get_profile_path()))
+                        } else {
+                            (None, None)
+                        }
                     }
                     x if x == self.get_subaction_path(Hand::Right) => {
-                        (Some(Hand::Right), Some(right_hand.get_profile_path()))
+                        if let Some(right_hand) = right_hand {
+                            (Some(Hand::Right), Some(right_hand.get_profile_path()))
+                        } else {
+                            (None, None)
+                        }
                     }
                     x if x == xr::Path::NULL => (None, None),
                     _ => unreachable!(),
                 };
 
                 let get_first_bound_hand_profile = || {
-                    loaded
-                        .try_get_pose(action, left_hand.get_profile_path())
-                        .or_else(|_| loaded.try_get_pose(action, right_hand.get_profile_path()))
-                        .ok()
+                    if let Some(left_hand) = left_hand {
+                        loaded
+                            .try_get_pose(action, left_hand.get_profile_path())
+                            .ok()
+                    } else if let Some(right_hand) = right_hand {
+                        loaded
+                            .try_get_pose(action, right_hand.get_profile_path())
+                            .ok()
+                    } else {
+                        None
+                    }
                 };
 
                 let Some(bound) = interaction_profile
@@ -1070,8 +1088,8 @@ impl<C: openxr_data::Compositor> vr::IVRInput010_Interface for Input<C> {
         let left_hand = devices.get_controller(Hand::Left.into());
         let right_hand = devices.get_controller(Hand::Right.into());
 
-        let left_profile = left_hand.get_profile_path();
-        let right_profile = right_hand.get_profile_path();
+        let left_profile = left_hand.map_or(xr::Path::NULL, |x| x.get_profile_path());
+        let right_profile = right_hand.map_or(xr::Path::NULL, |x| x.get_profile_path());
         for key in &actions.actions_with_custom_bindings {
             let unsync_custom_bindings = |key, profile| {
                 if profile == xr::Path::NULL {
@@ -1248,10 +1266,12 @@ impl<C: openxr_data::Compositor> vr::IVRInput005On006 for Input<C> {
 impl<C: openxr_data::Compositor> Input<C> {
     pub fn interaction_profile_changed(&self) {
         let session = self.openxr.session_data.get();
-        let devices = self.devices.read().unwrap();
-        let hmd = devices.get_hmd();
+        let mut devices = self.devices.write().unwrap();
+
+        let mut devices_to_create = vec![];
 
         for hand in [Hand::Left, Hand::Right] {
+            let hmd = devices.get_hmd();
             let controller = devices.get_controller(hand);
             let subaction_path = self.get_subaction_path(hand);
 
@@ -1260,15 +1280,24 @@ impl<C: openxr_data::Compositor> Input<C> {
                 .current_interaction_profile(subaction_path)
                 .unwrap();
 
-            controller.set_profile_path(profile_path);
+            //controller.set_profile_path(profile_path);
+            if let Some(controller) = controller {
+                controller.set_profile_path(profile_path);
+            }
 
             let profile_name = match profile_path {
                 xr::Path::NULL => {
-                    controller.set_connected(false);
+                    //controller.set_connected(false);
+                    if let Some(controller) = controller {
+                        controller.set_connected(false);
+                    }
                     "<null>".to_owned()
                 }
                 path => {
-                    controller.set_connected(true);
+                    //controller.set_connected(true);
+                    if let Some(controller) = controller {
+                        controller.set_connected(true);
+                    }
                     self.openxr.instance.path_to_string(path).unwrap()
                 }
             };
@@ -1276,7 +1305,25 @@ impl<C: openxr_data::Compositor> Input<C> {
             let profile = Profiles::get().profile_from_name(&profile_name);
 
             if let Some(p) = profile {
-                controller.set_interaction_profile(p);
+                //controller.set_interaction_profile(p);
+                if let Some(controller) = controller {
+                    controller.set_interaction_profile(p);
+                } else {
+                    // let new_controller = XrTrackedDevice::new(TrackedDeviceType::Controller { hand });
+
+                    // new_controller.set_profile_path(profile_path);
+                    // new_controller.set_connected(true);
+                    // new_controller.set_interaction_profile(p);
+
+                    // devices.push_device(new_controller).unwrap_or_else(|e| {
+                    //     panic!("Failed to create new controller: {:?}", e);
+                    // });
+                    devices_to_create.push(TrackedDeviceCreateInfo {
+                        device_type: TrackedDeviceType::Controller { hand },
+                        profile_path: Some(profile_path),
+                        interaction_profile: Some(p),
+                    });
+                }
                 hmd.set_interaction_profile(p);
             };
 
@@ -1288,6 +1335,15 @@ impl<C: openxr_data::Compositor> Input<C> {
                 profile_name
             )
         }
+
+        for device_info in devices_to_create {
+            let device = XrTrackedDevice::new(device_info);
+            device.set_connected(true);
+
+            devices.push_device(device).unwrap_or_else(|e| {
+                panic!("Failed to create new controller: {:?}", e);
+            });
+        }
     }
 
     pub fn frame_start_update(&self) {
@@ -1309,7 +1365,9 @@ impl<C: openxr_data::Compositor> Input<C> {
             // don't actually call UpdateActionState if no controllers are reported as connected,
             // and interaction profiles are only updated after xrSyncActions is called. So here, we
             // do an action sync to try and get the runtime to update the interaction profile.
-            if !left_hand.connected() || !right_hand.connected() {
+            if (left_hand.is_none() || !left_hand.unwrap().connected())
+                && (right_hand.is_none() || !right_hand.unwrap().connected())
+            {
                 debug!("no controllers connected - syncing info set");
                 data.session
                     .sync_actions(&[xr::ActiveActionSet::new(&loaded.info_set)])
diff --git a/src/input/devices.rs b/src/input/devices.rs
index 577f582..1f6a5f6 100644
--- a/src/input/devices.rs
+++ b/src/input/devices.rs
@@ -1,7 +1,10 @@
-use std::{ffi::CStr, sync::{
-    atomic::{AtomicBool, Ordering},
-    Mutex,
-}};
+use std::{
+    ffi::CStr,
+    sync::{
+        atomic::{AtomicBool, Ordering},
+        Mutex,
+    },
+};
 
 use openvr as vr;
 use openxr as xr;
@@ -17,20 +20,6 @@ pub enum TrackedDeviceType {
     Hmd,
     Controller { hand: Hand },
 }
-
-impl TryFrom<vr::TrackedDeviceIndex_t> for TrackedDeviceType {
-    type Error = ();
-
-    fn try_from(value: vr::TrackedDeviceIndex_t) -> Result<Self, Self::Error> {
-        match value {
-            0 => Ok(Self::Hmd),
-            1 => Ok(Self::Controller { hand: Hand::Left }),
-            2 => Ok(Self::Controller { hand: Hand::Right }),
-            _ => Err(()),
-        }
-    }
-}
-
 pub struct XrTrackedDevice {
     device_type: TrackedDeviceType,
     interaction_profile: Mutex<Option<&'static dyn InteractionProfile>>,
@@ -40,13 +29,25 @@ pub struct XrTrackedDevice {
     pose_cache: Mutex<Option<vr::TrackedDevicePose_t>>,
 }
 
+pub struct TrackedDeviceCreateInfo {
+    pub device_type: TrackedDeviceType,
+    pub profile_path: Option<xr::Path>,
+    pub interaction_profile: Option<&'static dyn InteractionProfile>,
+}
+
 impl XrTrackedDevice {
-    pub fn new(device_type: TrackedDeviceType) -> Self {
+    pub fn new(info: TrackedDeviceCreateInfo) -> Self {
+        let profile_path = AtomicPath::new();
+
+        if let Some(path) = info.profile_path {
+            profile_path.store(path);
+        }
+
         Self {
-            device_type,
-            interaction_profile: Mutex::new(None),
-            profile_path: AtomicPath::new(),
-            connected: if device_type == TrackedDeviceType::Hmd {
+            device_type: info.device_type,
+            interaction_profile: Mutex::new(info.interaction_profile),
+            profile_path,
+            connected: if info.device_type == TrackedDeviceType::Hmd {
                 true.into()
             } else {
                 false.into()
@@ -202,26 +203,52 @@ impl SubactionPaths {
 }
 
 impl TrackedDeviceList {
-    pub fn new() -> Self {
+    pub(super) fn new() -> Self {
         Self {
-            devices: vec![
-                XrTrackedDevice::new(TrackedDeviceType::Hmd),
-                XrTrackedDevice::new(TrackedDeviceType::Controller { hand: Hand::Left }),
-                XrTrackedDevice::new(TrackedDeviceType::Controller { hand: Hand::Right }),
-            ],
+            devices: vec![XrTrackedDevice::new(TrackedDeviceCreateInfo {
+                device_type: TrackedDeviceType::Hmd,
+                profile_path: None,
+                interaction_profile: None,
+            })],
         }
     }
 
-    pub fn get_device(&self, device_index: vr::TrackedDeviceIndex_t) -> Option<&XrTrackedDevice> {
+    pub(super) fn get_device(
+        &self,
+        device_index: vr::TrackedDeviceIndex_t,
+    ) -> Option<&XrTrackedDevice> {
         self.devices.get(device_index as usize)
     }
 
-    pub fn get_hmd(&self) -> &XrTrackedDevice {
+    pub(super) fn push_device(
+        &mut self,
+        device: XrTrackedDevice,
+    ) -> Result<vr::TrackedDeviceIndex_t, vr::EVRInputError> {
+        let index = self.devices.len() as vr::TrackedDeviceIndex_t;
+
+        if index >= vr::k_unMaxTrackedDeviceCount {
+            return Err(vr::EVRInputError::MaxCapacityReached);
+        }
+
+        self.devices.push(device);
+
+        Ok(index)
+    }
+
+    pub(super) fn get_hmd(&self) -> &XrTrackedDevice {
         unsafe { self.devices.get_unchecked(0) }
     }
 
-    pub fn get_controller(&self, hand: Hand) -> &XrTrackedDevice {
-        unsafe { self.devices.get_unchecked(hand as usize) }
+    pub(super) fn get_controller(&self, hand: Hand) -> Option<&XrTrackedDevice> {
+        self.get_device(self.get_controller_index(hand))
+    }
+
+    fn get_controller_index(&self, hand: Hand) -> vr::TrackedDeviceIndex_t {
+        self.iter()
+            .enumerate()
+            .find(|(_, device)| device.get_controller_hand() == Some(hand))
+            .map(|(i, _)| i as vr::TrackedDeviceIndex_t)
+            .unwrap_or(vr::k_unTrackedDeviceIndexInvalid)
     }
 
     pub fn iter(&self) -> std::slice::Iter<'_, XrTrackedDevice> {
@@ -259,7 +286,9 @@ impl<C: openxr_data::Compositor> Input<C> {
         hand: Hand,
         origin: Option<vr::ETrackingUniverseOrigin>,
     ) -> vr::TrackedDevicePose_t {
-        self.get_device_pose(hand.into(), origin)
+        let controller_index = self.devices.read().unwrap().get_controller_index(hand);
+
+        self.get_device_pose(controller_index, origin)
     }
 
     pub fn get_device_pose(
@@ -294,15 +323,41 @@ impl<C: openxr_data::Compositor> Input<C> {
         device.connected()
     }
 
-    fn get_profile_data(&self, hand: Hand) -> Option<&super::profiles::ProfileProperties> {
-        let path = self
-            .devices
-            .read()
-            .ok()?
-            .get_device(hand.into())?
-            .get_profile_path();
+    pub fn device_index_to_device_type(
+        &self,
+        index: vr::TrackedDeviceIndex_t,
+    ) -> Option<TrackedDeviceType> {
+        let devices = self.devices.read().ok()?;
+        let device = devices.get_device(index)?;
 
-        self.profile_map.get(&path).map(|v| &**v)
+        Some(device.get_type())
+    }
+
+    pub fn device_index_to_hand(&self, index: vr::TrackedDeviceIndex_t) -> Option<Hand> {
+        let devices = self.devices.read().ok()?;
+        let device = devices.get_device(index)?;
+
+        device.get_controller_hand()
+    }
+
+    pub fn get_controller_device_index(&self, hand: Hand) -> Option<vr::TrackedDeviceIndex_t> {
+        let devices = self.devices.read().ok()?;
+        let controller_index = devices.get_controller_index(hand);
+
+        if controller_index == vr::k_unTrackedDeviceIndexInvalid {
+            return None;
+        }
+
+        Some(controller_index)
+    }
+
+    fn get_profile_data(&self, hand: Hand) -> Option<&super::profiles::ProfileProperties> {
+        let devices = self.devices.read().ok()?;
+        let controller = devices.get_controller(hand)?;
+
+        self.profile_map
+            .get(&controller.get_profile_path())
+            .map(|v| &**v)
     }
 
     pub fn get_controller_string_tracked_property(
diff --git a/src/input/legacy.rs b/src/input/legacy.rs
index ab1d5f2..e69b031 100644
--- a/src/input/legacy.rs
+++ b/src/input/legacy.rs
@@ -99,7 +99,7 @@ impl<C: openxr_data::Compositor> Input<C> {
             return;
         }
 
-        let Ok(hand) = Hand::try_from(device_index) else {
+        let Some(hand) = self.device_index_to_hand(device_index) else {
             debug!("tried triggering haptic on invalid device index: {device_index}");
             return;
         };
@@ -163,8 +163,8 @@ impl<C: openxr_data::Compositor> Input<C> {
         };
         let actions = &legacy.actions;
 
-        let Ok(hand) = Hand::try_from(device_index) else {
-            debug!("requested controller state for invalid device index: {device_index}");
+        let Some(hand) = self.device_index_to_hand(device_index) else {
+            debug!("tried getting controller state, but device index {device_index} is invalid or not a controller!");
             return false;
         };
 
@@ -498,7 +498,7 @@ mod tests {
                 event.is_none(),
                 "Got unexpected event: {} ({msg})",
                 event.unwrap().ty
-            );  
+            );
         };
 
         let update_action_state = |left_state, right_state| {
@@ -551,7 +551,7 @@ mod tests {
         };
 
         let hands = [LeftHand, RightHand];
-        
+
         while let Some(event) = get_event() {
             assert_eq!(event.ty, vr::EVREventType::TrackedDeviceActivated as u32);
         }
diff --git a/src/input/skeletal.rs b/src/input/skeletal.rs
index e7bf352..015f66e 100644
--- a/src/input/skeletal.rs
+++ b/src/input/skeletal.rs
@@ -29,7 +29,10 @@ impl<C: openxr_data::Compositor> Input<C> {
         let display_time = self.openxr.display_time.get();
         let devices = self.devices.read().unwrap();
 
-        let controller = devices.get_controller(hand);
+        let Some(controller) = devices.get_controller(hand) else {
+            self.get_estimated_bones(session_data, space, hand, transforms);
+            return;
+        };
 
         let Some(raw) = match hand {
             Hand::Left => &pose_data.left_space,
@@ -178,7 +181,10 @@ impl<C: openxr_data::Compositor> Input<C> {
         let display_time = self.openxr.display_time.get();
         let devices = self.devices.read().unwrap();
 
-        let controller = devices.get_controller(hand);
+        let Some(controller) = devices.get_controller(hand) else {
+            self.get_estimated_bone_summary(session_data, summary_type, summary_data, hand);
+            return;
+        };
 
         let Some(raw) = match hand {
             Hand::Left => &pose_data.left_space,
diff --git a/src/input/tests.rs b/src/input/tests.rs
index fd46f5a..d4bc153 100644
--- a/src/input/tests.rs
+++ b/src/input/tests.rs
@@ -505,6 +505,18 @@ fn raw_pose_waitgetposes_and_skeletal_pose_identical() {
     let skel_handle = f.get_action_handle(c"/actions/set1/in/skellyl");
     f.load_actions(c"actions.json");
     f.set_interaction_profile(&Knuckles, LeftHand);
+
+    let frame = || {
+        f.input.openxr.poll_events();
+        f.input.frame_start_update();
+    };
+
+    // we need to wait two frames for the controller to be connected.
+    frame();
+    assert!(f.input.get_controller_device_index(super::Hand::Left).is_none());
+    frame();
+    assert!(f.input.get_controller_device_index(super::Hand::Left).is_some());
+
     let rot = Quat::from_rotation_x(-FRAC_PI_4);
     let pose = xr::Posef {
         position: xr::Vector3f {
@@ -962,20 +974,17 @@ fn detect_controller_after_manifest_load() {
         input.frame_start_update();
     };
 
-    let devices = f.input.devices.read().unwrap();
-
-    let left_hand = devices.get_controller(Hand::Left.into());
-
     frame();
-    assert!(!left_hand.connected());
+    assert!(f.input.get_controller_device_index(Hand::Left).is_none());
 
     f.set_interaction_profile(&Knuckles, fakexr::UserPath::LeftHand);
     frame();
     // Profile won't be set for this frame - we call sync after events have already been polled
-    assert!(!left_hand.connected());
+    assert!(f.input.get_controller_device_index(Hand::Left).is_none());
 
     frame();
-    assert!(left_hand.connected());
+    let index = f.input.get_controller_device_index(Hand::Left);
+    assert!(index.is_some_and(|i| f.input.is_device_connected(i)));
 }
 
 #[test]
diff --git a/src/openxr_data.rs b/src/openxr_data.rs
index 52cb6e3..5c6baf8 100644
--- a/src/openxr_data.rs
+++ b/src/openxr_data.rs
@@ -607,18 +607,6 @@ impl From<Hand> for HandPath {
     }
 }
 
-impl TryFrom<vr::TrackedDeviceIndex_t> for Hand {
-    type Error = ();
-    #[inline]
-    fn try_from(value: vr::TrackedDeviceIndex_t) -> Result<Self, Self::Error> {
-        match value {
-            x if x == Hand::Left as u32 => Ok(Hand::Left),
-            x if x == Hand::Right as u32 => Ok(Hand::Right),
-            _ => Err(()),
-        }
-    }
-}
-
 impl TryFrom<vr::ETrackedControllerRole> for Hand {
     type Error = ();
     #[inline]
@@ -631,12 +619,6 @@ impl TryFrom<vr::ETrackedControllerRole> for Hand {
     }
 }
 
-impl From<Hand> for vr::TrackedDeviceIndex_t {
-    fn from(hand: Hand) -> Self {
-        hand as vr::TrackedDeviceIndex_t
-    }
-}
-
 impl From<Hand> for vr::ETrackedControllerRole {
     fn from(hand: Hand) -> Self {
         match hand {
diff --git a/src/system.rs b/src/system.rs
index ca4d01f..23578c9 100644
--- a/src/system.rs
+++ b/src/system.rs
@@ -348,12 +348,22 @@ impl vr::IVRSystem022_Interface for System {
         pose: *mut vr::TrackedDevicePose_t,
     ) -> bool {
         if self.GetControllerState(device_index, state, state_size) {
+            let Some(input) = self.input.get() else {
+                return false;
+            };
+            let Some(hand) = input.device_index_to_hand(device_index) else {
+                return false;
+            };
+
             unsafe {
                 *pose.as_mut().unwrap() = self
                     .input
                     .get()
                     .unwrap()
-                    .get_controller_pose(Hand::try_from(device_index).unwrap(), Some(origin));
+                    .get_controller_pose(
+                        hand,
+                        Some(origin),
+                    );
             }
             true
         } else {
@@ -491,6 +501,13 @@ impl vr::IVRSystem022_Interface for System {
             return 0;
         }
 
+        let Some(input) = self.input.get() else {
+            if let Some(error) = unsafe { error.as_mut() } {
+                *error = vr::ETrackedPropertyError::InvalidDevice;
+            }
+            return 0;
+        };
+
         if let Some(error) = unsafe { error.as_mut() } {
             *error = vr::ETrackedPropertyError::Success;
         }
@@ -511,8 +528,11 @@ impl vr::IVRSystem022_Interface for System {
                 | vr::ETrackedDeviceProperty::ControllerType_String => Some(c"<unknown>"),
                 _ => None,
             },
-            x if Hand::try_from(x).is_ok() => self.input.get().and_then(|i| {
-                i.get_controller_string_tracked_property(Hand::try_from(x).unwrap(), prop)
+            x if input.device_index_to_hand(x).is_some() => self.input.get().and_then(|i| {
+                i.get_controller_string_tracked_property(
+                    input.device_index_to_hand(x).unwrap(),
+                    prop,
+                )
             }),
             _ => None,
         };
@@ -580,13 +600,23 @@ impl vr::IVRSystem022_Interface for System {
             return 0;
         }
 
+        let Some(input) = self.input.get() else {
+            if let Some(err) = unsafe { err.as_mut() } {
+                *err = vr::ETrackedPropertyError::InvalidDevice;
+            }
+            return 0;
+        };
+
         if let Some(err) = unsafe { err.as_mut() } {
             *err = vr::ETrackedPropertyError::Success;
         }
 
         match device_index {
-            x if Hand::try_from(x).is_ok() => self.input.get().and_then(|input| {
-                input.get_controller_uint_tracked_property(Hand::try_from(x).unwrap(), prop)
+            x if input.device_index_to_hand(x).is_some() => self.input.get().and_then(|input| {
+                input.get_controller_uint_tracked_property(
+                    input.device_index_to_hand(x).unwrap(),
+                    prop,
+                )
             }),
             _ => None,
         }
@@ -611,12 +641,23 @@ impl vr::IVRSystem022_Interface for System {
             return 0;
         }
 
+        let Some(input) = self.input.get() else {
+            if let Some(err) = unsafe { err.as_mut() } {
+                *err = vr::ETrackedPropertyError::InvalidDevice;
+            }
+            return 0;
+        };
+
         if let Some(err) = unsafe { err.as_mut() } {
             *err = vr::ETrackedPropertyError::Success;
         }
+
         match device_index {
-            x if Hand::try_from(x).is_ok() => self.input.get().and_then(|input| {
-                input.get_controller_int_tracked_property(Hand::try_from(x).unwrap(), prop)
+            x if input.device_index_to_hand(x).is_some() => self.input.get().and_then(|input| {
+                input.get_controller_int_tracked_property(
+                    input.device_index_to_hand(x).unwrap(),
+                    prop,
+                )
             }),
             _ => None,
         }
@@ -675,26 +716,43 @@ impl vr::IVRSystem022_Interface for System {
     }
 
     fn GetTrackedDeviceClass(&self, index: vr::TrackedDeviceIndex_t) -> vr::ETrackedDeviceClass {
-        TrackedDeviceType::try_from(index).map_or(vr::ETrackedDeviceClass::Invalid, |device| {
-            match device {
-                TrackedDeviceType::Hmd => vr::ETrackedDeviceClass::HMD,
-                TrackedDeviceType::Controller { .. } => vr::ETrackedDeviceClass::Controller,
-            }
-        })
+        self.input
+            .get()
+            .and_then(|input| match input.device_index_to_device_type(index) {
+                Some(TrackedDeviceType::Hmd) => Some(vr::ETrackedDeviceClass::HMD),
+                Some(TrackedDeviceType::Controller { .. }) => {
+                    Some(vr::ETrackedDeviceClass::Controller)
+                }
+                _ => None,
+            })
+            .unwrap_or(vr::ETrackedDeviceClass::Invalid)
     }
 
     fn GetControllerRoleForTrackedDeviceIndex(
         &self,
         index: vr::TrackedDeviceIndex_t,
     ) -> vr::ETrackedControllerRole {
-        Hand::try_from(index).map_or(vr::ETrackedControllerRole::Invalid, |hand| hand.into())
+        let Some(input) = self.input.get() else {
+            return vr::ETrackedControllerRole::Invalid;
+        };
+        input
+            .device_index_to_hand(index)
+            .map_or(vr::ETrackedControllerRole::Invalid, |hand| hand.into())
     }
 
     fn GetTrackedDeviceIndexForControllerRole(
         &self,
         role: vr::ETrackedControllerRole,
     ) -> vr::TrackedDeviceIndex_t {
-        Hand::try_from(role).map_or(vr::k_unTrackedDeviceIndexInvalid, |hand| hand.into())
+        let Some(input) = self.input.get() else {
+            return vr::k_unTrackedDeviceIndexInvalid;
+        };
+
+        Hand::try_from(role).map_or(vr::k_unTrackedDeviceIndexInvalid, |hand| {
+            input
+                .get_controller_device_index(hand)
+                .unwrap_or(vr::k_unTrackedDeviceIndexInvalid)
+        })
     }
     fn ApplyTransform(
         &self,
@@ -708,9 +766,13 @@ impl vr::IVRSystem022_Interface for System {
         &self,
         device_index: vr::TrackedDeviceIndex_t,
     ) -> vr::EDeviceActivityLevel {
+        let Some(input) = self.input.get() else {
+            return vr::EDeviceActivityLevel::Unknown;
+        };
+
         match device_index {
             vr::k_unTrackedDeviceIndex_Hmd => vr::EDeviceActivityLevel::UserInteraction,
-            x if Hand::try_from(x).is_ok() => {
+            x if input.device_index_to_hand(x).is_some() => {
                 if self.IsTrackedDeviceConnected(x) {
                     vr::EDeviceActivityLevel::UserInteraction
                 } else {
-- 
2.51.0


From c89b5462bef14a6153ebf673f016971901cac197 Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Fri, 25 Apr 2025 00:34:20 +0200
Subject: [PATCH 24/25] run cargo fmt

---
 src/input/tests.rs | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/src/input/tests.rs b/src/input/tests.rs
index d4bc153..1ce95c2 100644
--- a/src/input/tests.rs
+++ b/src/input/tests.rs
@@ -513,9 +513,15 @@ fn raw_pose_waitgetposes_and_skeletal_pose_identical() {
 
     // we need to wait two frames for the controller to be connected.
     frame();
-    assert!(f.input.get_controller_device_index(super::Hand::Left).is_none());
+    assert!(f
+        .input
+        .get_controller_device_index(super::Hand::Left)
+        .is_none());
     frame();
-    assert!(f.input.get_controller_device_index(super::Hand::Left).is_some());
+    assert!(f
+        .input
+        .get_controller_device_index(super::Hand::Left)
+        .is_some());
 
     let rot = Quat::from_rotation_x(-FRAC_PI_4);
     let pose = xr::Posef {
-- 
2.51.0


From 160630af6c6c76f31adab1c6109df99ed1d23e6e Mon Sep 17 00:00:00 2001
From: Sarah <xxklintan123xx@gmail.com>
Date: Fri, 25 Apr 2025 23:20:09 +0200
Subject: [PATCH 25/25] cleanup leftover comments

---
 src/input.rs | 13 -------------
 1 file changed, 13 deletions(-)

diff --git a/src/input.rs b/src/input.rs
index 8fbe930..4ce6900 100644
--- a/src/input.rs
+++ b/src/input.rs
@@ -1280,21 +1280,18 @@ impl<C: openxr_data::Compositor> Input<C> {
                 .current_interaction_profile(subaction_path)
                 .unwrap();
 
-            //controller.set_profile_path(profile_path);
             if let Some(controller) = controller {
                 controller.set_profile_path(profile_path);
             }
 
             let profile_name = match profile_path {
                 xr::Path::NULL => {
-                    //controller.set_connected(false);
                     if let Some(controller) = controller {
                         controller.set_connected(false);
                     }
                     "<null>".to_owned()
                 }
                 path => {
-                    //controller.set_connected(true);
                     if let Some(controller) = controller {
                         controller.set_connected(true);
                     }
@@ -1305,19 +1302,9 @@ impl<C: openxr_data::Compositor> Input<C> {
             let profile = Profiles::get().profile_from_name(&profile_name);
 
             if let Some(p) = profile {
-                //controller.set_interaction_profile(p);
                 if let Some(controller) = controller {
                     controller.set_interaction_profile(p);
                 } else {
-                    // let new_controller = XrTrackedDevice::new(TrackedDeviceType::Controller { hand });
-
-                    // new_controller.set_profile_path(profile_path);
-                    // new_controller.set_connected(true);
-                    // new_controller.set_interaction_profile(p);
-
-                    // devices.push_device(new_controller).unwrap_or_else(|e| {
-                    //     panic!("Failed to create new controller: {:?}", e);
-                    // });
                     devices_to_create.push(TrackedDeviceCreateInfo {
                         device_type: TrackedDeviceType::Controller { hand },
                         profile_path: Some(profile_path),
-- 
2.51.0

